<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assessments - Teacher Resource Platform</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <style>
        .question-card {
            margin-bottom: 1rem;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            padding: 1rem;
        }
        .audio-preview {
            max-width: 100%;
            margin-top: 0.5rem;
        }
        .choice-input {
            margin-bottom: 0.5rem;
        }
        .remove-question {
            float: right;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="#">Assessments</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="btn btn-outline-light me-2" href="/teacher/dashboard">
                            <i class="bi bi-speedometer2"></i> Dashboard
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="btn btn-outline-light me-2" href="/teacher/subjects">
                            <i class="bi bi-book"></i> Subjects
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="btn btn-outline-light me-2" href="/teacher/course-structure">
                            <i class="bi bi-diagram-3"></i> Course Structure
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="btn btn-outline-light" href="/teacher/resources">
                            <i class="bi bi-files"></i> Resources
                        </a>
                    </li>
                </ul>
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <button class="btn btn-outline-light" id="logoutBtn">
                            <i class="bi bi-box-arrow-right"></i> Logout
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-4">
        <div class="row mb-3">
            <div class="col-auto">
                <label for="quarterFilter" class="form-label mb-0 me-2">Quarter:</label>
                <select id="quarterFilter" class="form-select d-inline-block w-auto">
                    <option value="">All</option>
                    <option value="Q1">Q1</option>
                    <option value="Q2">Q2</option>
                    <option value="Q3">Q3</option>
                    <option value="Q4">Q4</option>
                </select>
            </div>
            <div class="col-auto">
                <label for="publishedFilter" class="form-label mb-0 me-2">Published:</label>
                <select id="publishedFilter" class="form-select d-inline-block w-auto">
                    <option value="">All</option>
                    <option value="true">Published</option>
                    <option value="false">Unpublished</option>
                </select>
            </div>
        </div>
        <div class="row">
            <!-- Left panel: selectors and form -->
            <div class="col-lg-5 col-xl-4">
                <div class="card mb-4">
                    <div class="card-header">
                        <h4>Create New Assessment</h4>
                    </div>
                    <div class="card-body">
                        <div id="structurePath"></div>
                        <form id="assessmentForm">
                            <div class="mb-3">
                                <label for="subjectSelect" class="form-label">Subject</label>
                                <select class="form-select" id="subjectSelect" required>
                                    <option value="">Select subject...</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label for="unitSelect" class="form-label">Unit</label>
                                <select class="form-select" id="unitSelect" required disabled>
                                    <option value="">Select unit...</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label for="partSelect" class="form-label">Part</label>
                                <select class="form-select" id="partSelect" required disabled>
                                    <option value="">Select part...</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label for="sectionSelect" class="form-label">Section</label>
                                <select class="form-select" id="sectionSelect" required disabled>
                                    <option value="">Select section...</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label for="title" class="form-label">Title</label>
                                <input type="text" class="form-control" id="title" name="title" required placeholder="Enter assessment title">
                            </div>

                            <div class="mb-3">
                                <label for="type" class="form-label">Type</label>
                                <select class="form-select" id="type" name="type" required onchange="handleTypeChange(); updateQuestionOptions();">
                                    <option value="multiple-choice">Multiple Choice</option>
                                    <option value="true-false">True/False</option>
                                    <option value="matching">Matching</option>
                                    <option value="drag-and-drop">Drag and Drop</option>
                                    <option value="change-sequence">Change-Sequence</option>
                                    <option value="writing">Writing</option>
                                    <option value="writing-long">Writing (Long)</option>
                                    <option value="speaking">Speaking</option>
                                    <option value="assignment">Fill-in-the-Blank Text</option>
                                    <option value="listening">Listening Comprehension</option>
                                </select>
                            </div>
                            <div class="mb-3" id="subtypeContainer" style="display:none;">
                                <label for="subtype" class="form-label">Subtype</label>
                                <select class="form-select" id="subtype" name="subtype" onchange="updateQuestionOptions();">
                                    <option value="sequence">Sequence (with Audio & Word Bank)</option>
                                    <option value="fill-in-blank">Fill-in-the-Blank</option>
                                    <option value="image-fill-blank">Image Fill-in-the-Blank</option>
                                    <option value="long-paragraph-fill-in-blank">Long Paragraph Fill-in-the-Blank</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label for="assessmentCategory" class="form-label">Category/Skill</label>
                                <input type="text" class="form-control" id="assessmentCategory" name="category" placeholder="E.g., Grammar, Vocabulary, Listening, etc.">
                            </div>

                            <div class="mb-3">
                                <label for="description" class="form-label">Description</label>
                                <textarea class="form-control" id="description" rows="3"></textarea>
                            </div>
                            <div class="mb-3" id="criteriaContainer">
                                <label for="criteria" class="form-label">Grading Criteria</label>
                                <textarea class="form-control" id="criteria" rows="3" placeholder="Enter grading criteria or rubric for this assessment"></textarea>
                            </div>
                            
                            <!-- Audio upload section for listening exercises -->
                            <div class="mb-4" id="audioUploadContainer">
                                <div class="card">
                                    <div class="card-header bg-info bg-opacity-25">
                                        <h5 class="mb-0">
                                            <i class="bi bi-volume-up me-2"></i>Audio for Listening Exercise
                                        </h5>
                                    </div>
                                    <div class="card-body">
                                        <p class="text-muted mb-3">
                                            For listening exercises, upload an audio file that students will listen to before answering questions.
                                            This is especially important for assessments with type "Multiple Choice" or "Listening".
                                        </p>
                                        <div class="mb-3">
                                            <label for="assessmentAudio" class="form-label">Upload Audio File</label>
                                            <input type="file" class="form-control" id="assessmentAudio" accept="audio/*" onchange="previewAudio(this)">
                                            <audio id="audioPreview" controls style="display: none; margin-top: 10px; width: 100%;"></audio>
                                            <input type="hidden" id="audioUrl" name="audioUrl">
                                            <div class="form-text">Supported formats: MP3, WAV, OGG</div>
                                        </div>
                                        <button type="button" class="btn btn-outline-danger btn-sm mt-2" id="removeAudioBtn" style="display:none;">Remove Audio</button>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label for="dueDate" class="form-label">Due Date</label>
                                <input type="datetime-local" class="form-control" id="dueDate">
                            </div>

                            <div class="mb-3">
                                <label for="quarter" class="form-label">Quarter</label>
                                <select class="form-select" id="quarter" name="quarter" required>
                                    <option value="Q1">Q1</option>
                                    <option value="Q2">Q2</option>
                                    <option value="Q3">Q3</option>
                                    <option value="Q4">Q4</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label for="maxAttempts" class="form-label">Maximum Attempts (optional)</label>
                                <input type="number" class="form-control" id="maxAttempts" min="1" placeholder="Leave blank for unlimited attempts">
                            </div>

                            <div id="questionsSection">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h5>Questions</h5>
                                    <div class="btn-group" id="questionButtonsContainer"></div>
                                </div>
                                <div id="questionsList" class="mb-4"></div>
                            </div>

                            <!-- Bulk Import for Multiple Choice -->
                            <div id="bulkImportContainer" style="display:none; margin-bottom:1em;">
                                <label for="bulkImportFile" class="form-label">Bulk Import Questions (JSON):</label>
                                <input type="file" id="bulkImportFile" accept="application/json" class="form-control" />
                                <button type="button" class="btn btn-primary mt-2" onclick="handleBulkImport()">Import File</button>
                                <button type="button" class="btn btn-secondary mt-2 ms-2" onclick="showPasteJsonModal()">Paste JSON</button>
                                <div id="bulkImportError" class="text-danger mt-2" style="display:none;"></div>
                            </div>

                            <!-- Paste JSON Modal -->
                            <div class="modal fade" id="pasteJsonModal" tabindex="-1" aria-labelledby="pasteJsonModalLabel" aria-hidden="true">
                              <div class="modal-dialog">
                                <div class="modal-content">
                                  <div class="modal-header">
                                    <h5 class="modal-title" id="pasteJsonModalLabel">Paste JSON Questions</h5>
                                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                  </div>
                                  <div class="modal-body">
                                    <textarea id="pastedJson" class="form-control" rows="10" placeholder='{
  "questions": [
    {
      "type": "multiple-choice",
      "text": "What is the capital of France?",
      "options": ["London", "Berlin", "Paris", "Madrid"],
      "correctAnswer": 2
    },
    {
      "type": "multiple-choice",
      "text": "Which planet is known as the Red Planet?",
      "options": ["Earth", "Mars", "Jupiter", "Venus"],
      "correctAnswer": 1
    }
  ]
}'></textarea>
                                    <div id="pasteJsonError" class="text-danger mt-2"></div>
                                  </div>
                                  <div class="modal-footer">
                                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                    <button type="button" class="btn btn-primary" onclick="handlePasteJsonImport()">Import</button>
                                  </div>
                                </div>
                              </div>
                            </div>

                            <div class="mt-4">
                                <button type="submit" class="btn btn-primary" id="createAssessmentBtn">Create Assessment</button>
                                <button type="button" class="btn btn-success" id="saveAssessmentBtn" style="display:none;">Save Changes</button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
            <!-- Right panel: existing assessments grid -->
            <div class="col-lg-7 col-xl-8">
                <div class="card">
                    <div class="card-header">
                        <h4>Existing Assessments</h4>
                    </div>
                    <div class="card-body">
                        <div id="existingAssessments" class="row g-3">
                            <!-- Assessments will be loaded here as grid -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/js/logout.js"></script>
    <script>
        const token = localStorage.getItem('token');
        if (!token) {
            window.location.href = '/login';
        }

        // logout() function is now provided by logout.js utility
        
        // Add event listener to logout button
        document.getElementById('logoutBtn').addEventListener('click', logout);

        // Load subjects when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Check authentication
            if (!token) {
                window.location.href = '/login';
            }
            
            // Initialize the page
            loadSubjects();
            loadExistingAssessments();
            updateQuestionOptions();
            
            // Initialize the type change handler
            handleTypeChange();
            
            // Add event listener for type change
            document.getElementById('type').addEventListener('change', handleTypeChange);
            
            // Fix for "invalid form control" errors
            // Remove required attribute from any inputs that might cause issues
            document.getElementById('assessmentForm').addEventListener('submit', function(e) {
                // Find any problematic inputs by name pattern
                const expressionInputs = document.querySelectorAll('input[name^="expression_question_"]');
                const meaningInputs = document.querySelectorAll('input[name^="meaning_question_"]');
                
                // Remove required attribute from all of them
                expressionInputs.forEach(input => input.removeAttribute('required'));
                meaningInputs.forEach(input => input.removeAttribute('required'));
                
                // Check if any drag-and-drop long paragraph questions are present
                if (document.getElementById('type').value === 'drag-and-drop' && 
                    document.getElementById('subtype').value === 'long-paragraph-fill-in-blank') {
                    console.log('Long paragraph drag-and-drop detected, removing required attributes');
                    // Find ALL form inputs with required attribute in question cards
                    const questionCards = document.querySelectorAll('.question-card[data-type="drag-and-drop"]');
                    questionCards.forEach(card => {
                        const requiredInputs = card.querySelectorAll('[required]');
                        requiredInputs.forEach(input => input.removeAttribute('required'));
                    });
                }
            });
        });

        // Handle subject selection
        document.getElementById('subjectSelect').addEventListener('change', function() {
            const subjectId = this.value;
            if (subjectId) {
                loadUnits(subjectId);
                document.getElementById('unitSelect').disabled = false;
                // Load assessments filtered by subject
                loadExistingAssessments(subjectId);
            } else {
                document.getElementById('unitSelect').disabled = true;
                document.getElementById('partSelect').disabled = true;
                document.getElementById('sectionSelect').disabled = true;
                // Load all assessments when no subject is selected
                loadExistingAssessments();
            }
        });

        // Handle unit selection
        document.getElementById('unitSelect').addEventListener('change', function() {
            const unitId = this.value;
            if (unitId) {
                loadParts(unitId);
                document.getElementById('partSelect').disabled = false;
            } else {
                document.getElementById('partSelect').disabled = true;
                document.getElementById('sectionSelect').disabled = true;
            }
        });

        // Handle part selection
        document.getElementById('partSelect').addEventListener('change', function() {
            const partId = this.value;
            if (partId) {
                loadSections(partId);
                document.getElementById('sectionSelect').disabled = false;
            } else {
                document.getElementById('sectionSelect').disabled = true;
            }
        });

        async function loadSubjects() {
            try {
                const response = await fetch('/api/subjects', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                const subjects = await response.json();
                const select = document.getElementById('subjectSelect');
                select.innerHTML = '<option value="">Select subject...</option>';
                
                // Sort subjects by core subject name and year level
                subjects.sort((a, b) => {
                    if (a.coreSubject.name === b.coreSubject.name) {
                        return a.yearLevel - b.yearLevel;
                    }
                    return a.coreSubject.name.localeCompare(b.coreSubject.name);
                });

                subjects.forEach(subject => {
                    const option = document.createElement('option');
                    option.value = subject.id;
                    
                    // Convert year level number back to P1-P6 or M1-M3 format
                    let yearLevelStr = '';
                    if (subject.yearLevel <= 6) {
                        yearLevelStr = `P${subject.yearLevel}`;
                    } else {
                        yearLevelStr = `M${subject.yearLevel - 6}`;
                    }
                    
                    // Display format: "English (M3) - [Actual Subject Name]"
                    option.textContent = `${subject.coreSubject.name} (${yearLevelStr}) - ${subject.name}`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading subjects:', error);
            }
        }

        async function loadUnits(subjectId) {
            try {
                const response = await fetch(`/api/subjects/${subjectId}/units`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                const units = await response.json();
                const select = document.getElementById('unitSelect');
                select.innerHTML = '<option value="">Select unit...</option>';
                
                units.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit.id;
                    option.textContent = unit.name;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading units:', error);
            }
        }

        async function loadParts(unitId) {
            try {
                const response = await fetch(`/api/units/${unitId}/parts`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                const parts = await response.json();
                const select = document.getElementById('partSelect');
                select.innerHTML = '<option value="">Select part...</option>';
                
                parts.forEach(part => {
                    const option = document.createElement('option');
                    option.value = part.id;
                    option.textContent = `${part.name} (Order: ${part.order})`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading parts:', error);
            }
        }

        async function loadSections(partId) {
            try {
                const response = await fetch(`/api/parts/${partId}/sections`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                const sections = await response.json();
                const select = document.getElementById('sectionSelect');
                select.innerHTML = '<option value="">Select section...</option>';
                
                sections.forEach(section => {
                    const option = document.createElement('option');
                    option.value = section.id;
                    option.textContent = `${section.name} (Order: ${section.order})`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading sections:', error);
            }
        }

        // Add MutationObserver for #questionsSection
        (function() {
            const qs = document.getElementById('questionsSection');
            if (qs && !qs._mutationObserverAdded) {
                new MutationObserver((mutations) => {
                    mutations.forEach(m => {
                        if (m.attributeName === 'style') {
                            console.log('[MutationObserver] questionsSection style changed:', qs.style.display, new Date());
                        }
                    });
                }).observe(qs, { attributes: true, attributeFilter: ['style'] });
                qs._mutationObserverAdded = true;
            }
        })();

        function updateQuestionOptions() {
            const type = document.getElementById('type').value;
            console.log('[updateQuestionOptions] called, type:', type, 'at', new Date());
            const buttonsContainer = document.getElementById('questionButtonsContainer');
            if (!buttonsContainer) {
                console.error('[updateQuestionOptions] questionButtonsContainer not found!');
                return;
            }
            switch(type) {
                case 'multiple-choice':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('multiple-choice')">
                            <i class="bi bi-list-check"></i> Add Multiple Choice
                        </button>
                        <button type="button" class="btn btn-outline-secondary ms-2" onclick="showBulkImport()">
                            <i class="bi bi-upload"></i> Bulk Import Questions
                        </button>`;
                    break;
                case 'listening':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('listening')">
                            <i class="bi bi-headphones"></i> Add Listening
                        </button>`;
                    break;
                case 'speaking':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('speaking')">
                            <i class="bi bi-mic"></i> Add Speaking
                        </button>`;
                    break;
                case 'matching':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('matching')">
                            <i class="bi bi-arrow-left-right"></i> Add Matching Exercise
                        </button>`;
                    break;
                case 'drag-and-drop':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('drag-and-drop')">
                            <i class="bi bi-arrows-move"></i> Add Drag-and-Drop
                        </button>`;
                    break;
                case 'true-false':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('true-false')">
                            <i class="bi bi-check2-square"></i> Add True/False
                        </button>`;
                    break;
                case 'writing':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('writing')">
                            <i class="bi bi-pencil"></i> Add Writing Question
                        </button>
                        <button type="button" class="btn btn-outline-secondary ms-2" onclick="showBulkImportWritingModal()">
                            <i class="bi bi-upload"></i> Bulk Import Questions
                        </button>`;
                    break;
                case 'assignment':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('assignment')">
                            <i class="bi bi-input-cursor-text"></i> Add Fill-in-the-Blank Text
                        </button>`;
                    break;
                case 'change-sequence':
                    buttonsContainer.innerHTML = `
                        <button type="button" class="btn btn-outline-primary" onclick="addQuestion('change-sequence')">
                            <i class="bi bi-arrow-down-up"></i> Add Change-Sequence
                        </button>`;
                    break;
                default:
                    buttonsContainer.innerHTML = '';
            }
            console.log('[updateQuestionOptions] questionButtonsContainer updated for type:', type, 'at', new Date());
            // Show/hide Bulk Import for multiple-choice
            const bulkImportBtn = document.getElementById('bulkImportBtn');
            if (bulkImportBtn) {
                bulkImportBtn.style.display = (type === 'multiple-choice') ? '' : 'none';
            }
            const bulkImportContainer = document.getElementById('bulkImportContainer');
            if (bulkImportContainer) {
                bulkImportContainer.style.display = (type === 'multiple-choice') ? '' : 'none';
            }
            // Always set questionsSection display at the end
            const questionsSection = document.getElementById('questionsSection');
            if (questionsSection) {
                const showQuestions = ['multiple-choice', 'drag-and-drop', 'matching', 'true-false', 'mixed', 'assignment', 'change-sequence'].includes(type);
                questionsSection.style.display = showQuestions ? 'block' : 'none';
            }
            // Always show Create Assessment button for true-false
            const createBtn = document.getElementById('createAssessmentBtn');
            if (createBtn) {
                if (type === 'true-false') {
                    createBtn.style.display = 'inline-block';
                }
            }
            // Log all event listeners on assessmentType (if possible)
            const at = document.getElementById('type');
            if (at) {
                try {
                    if (typeof getEventListeners === 'function') {
                        console.log('[updateQuestionOptions] assessmentType event listeners:', getEventListeners(at));
                    } else {
                        console.log('[updateQuestionOptions] assessmentType onchange:', at.onchange);
                    }
                } catch (e) {
                    console.log('[updateQuestionOptions] Could not log event listeners:', e);
                }
            }
        }

        function addQuestion(type, questionData) {
            // Prevent duplicate change-sequence cards
            if (type === 'change-sequence') {
                const existing = document.querySelector('.question-card[data-type="change-sequence"]');
                if (existing) {
                    alert('Only one Change-Sequence question is allowed per assessment.');
                    return;
                }
            }
            console.log('addQuestion called with type:', type, 'data:', questionData);
            const questionsList = document.getElementById('questionsList');
            if (!questionsList) {
                console.error('questionsList container not found!');
                return;
            }
            const questionId = 'question_' + Date.now() + Math.floor(Math.random() * 10000);
            let questionHtml = `
                <div class="card mb-3 question-card" id="${questionId}" data-type="${type}">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">${type.charAt(0).toUpperCase() + type.slice(1)} Question</h6>
                        <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeQuestion('${questionId}')">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                    <div class="card-body">`;

            switch(type) {
                case 'multiple-choice':
                    questionHtml += `
                        <div class="mb-3">
                            <label class="form-label">Question Text</label>
                            <textarea class="form-control" rows="2" required></textarea>
                        </div>
                        <div class="choices-container">
                            <label class="form-label">Choices</label>
                            <div class="mb-2">
                                <div class="input-group">
                                    <div class="input-group-text">
                                        <input type="radio" name="correct_${questionId}" required>
                                    </div>
                                    <input type="text" class="form-control" placeholder="Choice 1" required>
                                    <button type="button" class="btn btn-outline-danger" onclick="removeChoice(this)">
                                        <i class="bi bi-dash"></i>
                                    </button>
                                </div>
                            </div>
                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="addChoice('${questionId}')">
                                <i class="bi bi-plus"></i> Add Choice
                            </button>
                        </div>`;
                    break;

                case 'listening':
                    questionHtml += `
                        <div class="mb-3">
                            <label class="form-label">Audio File</label>
                            <input type="file" class="form-control" accept="audio/*" required>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Question Text</label>
                            <textarea class="form-control" rows="2" placeholder="What did you hear?" required></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Expected Answer</label>
                            <textarea class="form-control" rows="2" placeholder="Correct answer or key points to listen for" required></textarea>
                        </div>`;
                    break;

                case 'speaking':
                    questionHtml += `
                        <div class="mb-3">
                            <label class="form-label">Speaking Prompt</label>
                            <textarea class="form-control" rows="2" placeholder="What should the student talk about?" required></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Response Type</label>
                            <select class="form-control" onchange="toggleResponseType(this)">
                                <option value="audio">Audio Only</option>
                                <option value="video">Video</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Time Limit (seconds)</label>
                            <input type="number" class="form-control" min="10" max="300" value="60" required>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Evaluation Criteria</label>
                            <textarea class="form-control" rows="3" placeholder="How will you evaluate the response? (pronunciation, fluency, content, etc.)" required></textarea>
                        </div>`;
                    break;

                case 'matching':
                    questionHtml += `
                        <div class="d-flex justify-content-end mb-3">
                            <button type="button" class="btn btn-outline-secondary" onclick="bulkImportMatchingPairs('${questionId}')">
                                <i class="bi bi-upload"></i> Bulk Import Pairs
                            </button>
                        </div>
                        <div class="matching-pairs">
                            <div class="row mb-2">
                                <div class="col-md-5">
                                    <label class="form-label">Expression</label>
                                </div>
                                <div class="col-md-5">
                                    <label class="form-label">Meaning</label>
                                </div>
                                <div class="col-md-2">
                                    <label class="form-label">Actions</label>
                                </div>
                            </div>
                            <div class="matching-pair">
                                <div class="row mb-2">
                                    <div class="col-md-5">
                                        <input type="text" class="form-control" name="expression_${questionId}_0" placeholder="Enter expression">
                                    </div>
                                    <div class="col-md-5">
                                        <input type="text" class="form-control" name="meaning_${questionId}_0" placeholder="Enter meaning">
                                    </div>
                                    <div class="col-md-2">
                                        <button type="button" class="btn btn-outline-danger" onclick="removeMatchingPair(this)">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-outline-primary btn-sm mt-2" onclick="addMatchingPair('${questionId}')">
                            <i class="bi bi-plus"></i> Add Pair
                        </button>
                        <button type="button" class="btn btn-outline-success btn-sm mt-2" onclick="previewMatchingExercise('${questionId}')">
                            <i class="bi bi-eye"></i> Preview Exercise
                        </button>`;
                    break;

                case 'drag-and-drop':
                    questionHtml += `
                        <div class="mb-3 optional-image-upload">
                            <label class="form-label">Optional Picture (shown above word bank)</label>
                            <input type="file" class="form-control optional-image-input" accept="image/*">
                            <input type="hidden" class="optional-image-server-path">
                            <div class="optional-image-preview mt-2" style="max-width: 200px;"></div>
                        </div>
                        <div class="dragdrop-sequence-fields" style="display:none;">
                            <label class="form-label">Audio File (optional)</label>
                            <input type="file" class="form-control sequence-audio" accept="audio/*">
                            <label class="form-label mt-2">Word Bank (comma-separated)</label>
                            <input type="text" class="form-control sequence-items" placeholder="August, September, October, November, December">
                            <label class="form-label mt-2">Correct Sequence (comma-separated, use words from the word bank in order)</label>
                            <input type="text" class="form-control sequence-correct" placeholder="September, October, November, December">
                            <label class="form-label mt-2">Extra Word Bank Words (optional, comma-separated)</label>
                            <input type="text" class="form-control sequence-extra" placeholder="trick1, trick2">
                            <label class="form-label mt-2">Audio Display Name (optional)</label>
                            <input type="text" class="form-control sequence-audio-display-name" placeholder="e.g. Months of the Year Audio">
                        </div>
                        <div class="dragdrop-fillblank-fields" style="display:none;">
                            <label class="form-label">Sentences with [BLANK] and correct answers</label>
                            <div class="fillblank-sentences-list"></div>
                            <button type="button" class="btn btn-outline-primary btn-sm mt-2" onclick="window.addFillBlankSentence(this)"><i class="bi bi-plus"></i> Add Sentence</button>
                            <button type="button" class="btn btn-outline-secondary btn-sm mt-2" onclick="window.showBulkImportFillBlankModal(this)"><i class="bi bi-upload"></i> Bulk Import</button>
                            <label class="form-label mt-2">Extra Word Bank Words (optional, comma-separated)</label>
                            <input type="text" class="form-control fillblank-extra" placeholder="trick1, trick2">
                        </div>
                        <div class="dragdrop-image-fillblank-fields" style="display:none;">
                            <label class="form-label">Image-Sentence Pairs</label>
                            <div class="image-fillblank-pairs-list"></div>
                            <button type="button" class="btn btn-outline-primary btn-sm mt-2" onclick="window.addImageFillBlankPair(this)"><i class="bi bi-plus"></i> Add Pair</button>
                            <button type="button" class="btn btn-outline-secondary btn-sm mt-2" onclick="window.showBulkImportImageFillBlankModal(this)"><i class="bi bi-upload"></i> Bulk Import</button>
                            <label class="form-label mt-2">Extra Word Bank Words (optional, comma-separated)</label>
                            <input type="text" class="form-control imagefillblank-extra" placeholder="trick1, trick2">
                        </div>
                        <div class="dragdrop-long-paragraph-fields" style="display:none;">
                            <label class="form-label">Audio File (optional)</label>
                            <input type="file" class="form-control long-paragraph-audio" accept="audio/*">
                            <div class="audio-preview mt-2" style="display: none;"></div>
                            <input type="hidden" class="audio-file-path">
                            <label class="form-label mt-2">Audio Display Name (optional)</label>
                            <input type="text" class="form-control long-paragraph-audio-display-name" placeholder="e.g. Weather Forecast Audio">
                            <label class="form-label mt-3">Paragraph (use [BLANK] for blanks)</label>
                            <textarea class="form-control long-paragraph-text" rows="5" placeholder="Type a paragraph with [BLANK] for each blank."></textarea>
                            <label class="form-label mt-2">Word Bank (comma-separated)</label>
                            <input type="text" class="form-control long-paragraph-wordbank" placeholder="word1, word2, word3">
                            <label class="form-label mt-2">Correct Answers (comma-separated, in order)</label>
                            <input type="text" class="form-control long-paragraph-answers" placeholder="answer1, answer2, answer3">
                            <label class="form-label mt-2">Extra Word Bank Words (optional, comma-separated)</label>
                            <input type="text" class="form-control long-paragraph-extra" placeholder="trick1, trick2">
                            <small class="form-text text-muted mt-2">Note: When creating a long paragraph format, make sure to check that the number of [BLANK] placeholders matches the number of correct answers.</small>
                        </div>
                        <div class="dragdrop-matching-fields" style="display:none;">
                            <div class="d-flex justify-content-end mb-3">
                                <button type="button" class="btn btn-outline-secondary" onclick="bulkImportDragDropPairs('${questionId}')">
                                    <i class="bi bi-upload"></i> Bulk Import Pairs
                                </button>
                            </div>
                            <div class="dragdrop-pairs">
                                <div class="row mb-2">
                                    <div class="col-md-5">
                                        <label class="form-label">Expression</label>
                                    </div>
                                    <div class="col-md-5">
                                        <label class="form-label">Meaning</label>
                                    </div>
                                    <div class="col-md-2">
                                        <label class="form-label">Actions</label>
                                    </div>
                                </div>
                                <div class="dragdrop-pair">
                                    <div class="row mb-2">
                                        <div class="col-md-5">
                                            <input type="text" class="form-control" name="expression_${questionId}_0" placeholder="Enter expression">
                                        </div>
                                        <div class="col-md-5">
                                            <input type="text" class="form-control" name="meaning_${questionId}_0" placeholder="Enter meaning">
                                        </div>
                                        <div class="col-md-2">
                                            <button type="button" class="btn btn-outline-danger" onclick="removeDragDropPair(this)">
                                                <i class="bi bi-trash"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <button type="button" class="btn btn-outline-primary btn-sm mt-2" onclick="addDragDropPair('${questionId}')">
                                <i class="bi bi-plus"></i> Add Pair
                            </button>
                            <button type="button" class="btn btn-outline-success btn-sm mt-2" onclick="previewDragDropExercise('${questionId}')">
                                <i class="bi bi-eye"></i> Preview Exercise
                            </button>
                        </div>`;
                    break;

                case 'true-false':
                    questionHtml += `
                        <div class="true-false-sentences">
                            ${questionData && Array.isArray(questionData.sentences) && questionData.sentences.length > 0
                                ? questionData.sentences.map((sentence, idx) => `
                                    <div class="tf-sentence-row mb-2 d-flex align-items-center">
                                        <input type="text" class="form-control me-2" placeholder="Enter sentence" required style="max-width: 70%" value="${sentence.text ? sentence.text.replace(/"/g, '&quot;') : ''}">
                                        <button type="button" class="btn btn-outline-secondary tf-toggle ${sentence.isTrue === true ? 'btn-success' : sentence.isTrue === false ? 'btn-danger' : ''}" data-state="${sentence.isTrue === true ? 'T' : sentence.isTrue === false ? 'F' : ''}" onclick="toggleTfButton(this)">${sentence.isTrue === true ? 'T' : sentence.isTrue === false ? 'F' : '?'}</button>
                                        <button type="button" class="btn btn-outline-danger ms-2" onclick="removeTfSentence(this)"><i class="bi bi-trash"></i></button>
                                    </div>
                                `).join('')
                                : `<div class=\"tf-sentence-row mb-2 d-flex align-items-center\">\n<input type=\"text\" class=\"form-control me-2\" placeholder=\"Enter sentence\" required style=\"max-width: 70%\">\n<button type=\"button\" class=\"btn btn-outline-secondary tf-toggle\" data-state=\"\" onclick=\"toggleTfButton(this)\">?</button>\n<button type=\"button\" class=\"btn btn-outline-danger ms-2\" onclick=\"removeTfSentence(this)\"><i class=\"bi bi-trash\"></i></button>\n</div>`}
                        </div>
                        <button type="button" class="btn btn-outline-primary btn-sm mt-2" onclick="addTfSentence(this)"><i class="bi bi-plus"></i> Add Sentence</button>
                    `;
                    break;

                case 'writing':
                    questionHtml += `
                        <div class="mb-3">
                            <label class="form-label">Question</label>
                            <input type="text" class="form-control" placeholder="Enter the question (prompt)" required>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Correct Answer</label>
                            <input type="text" class="form-control" placeholder="Enter the correct answer" required>
                        </div>`;
                    break;

                case 'writing-long':
                    questionHtml += `
                        <div class="mb-3">
                            <label class="form-label">Prompt</label>
                            <textarea class="form-control" rows="3" placeholder="Enter the writing prompt" required></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Allow students to upload a file (Word, PDF, image, etc.)</label>
                            <input type="file" class="form-control" accept=".doc,.docx,.pdf,.jpg,.jpeg,.png">
                            <div class="form-text">Students can type their answer, upload a file, or both.</div>
                        </div>`;
                    break;

                case 'assignment':
                    questionHtml += `
                        <div class="card mb-3 question-card" data-type="assignment">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <h5 class="mb-0">Fill-in-the-Blank Text</h5>
                                <button type="button" class="btn-close" aria-label="Close" onclick="removeQuestion(this)"></button>
                            </div>
                            <div class="card-body">
                                <div class="mb-3">
                                    <label class="form-label">Text with Blanks</label>
                                    <p class="text-muted small">Use [BLANK:answer] where you want blanks to appear. Example: My name is [BLANK:John].</p>
                                    <textarea class="form-control text-with-blanks" rows="10" required>${questionData?.text || ''}</textarea>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Instructions</label>
                                    <textarea class="form-control assignment-instructions" rows="2">${questionData?.instructions || 'Fill in the blanks with the correct words.'}</textarea>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Audio File (optional)</label>
                                    <input type="file" class="form-control assignment-audio" accept="audio/*">
                                    <div class="audio-preview mt-2" style="display: none;"></div>
                                    <input type="hidden" class="audio-file-path">
                                    <small class="form-text text-muted">Students can listen to this audio while completing the fill-in-the-blank exercise.</small>
                                </div>
                                <div class="mb-3 form-check">
                                    <input type="checkbox" class="form-check-input case-sensitive" id="caseSensitive_${questionId}" ${questionData?.caseSensitive ? 'checked' : ''}>
                                    <label class="form-check-label" for="caseSensitive_${questionId}">Case Sensitive Answers</label>
                                </div>
                            </div>
                        </div>
                    `;
                    break;
                case 'change-sequence':
                    // Only insert the inner fields, not a nested card
                    questionHtml += `
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Change-Sequence Question</h5>
                            <button type="button" class="btn-close" aria-label="Close" onclick="removeQuestion('${questionId}')"></button>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label">Instructions</label>
                                <textarea class="form-control sequence-instructions" rows="2" required>${questionData?.instructions || 'Arrange the items in the correct sequence.'}</textarea>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Items (one per line)</label>
                                <textarea class="form-control sequence-items" rows="5" required placeholder="Enter items to be sequenced, one per line">${questionData?.items ? questionData.items.join('\n') : ''}</textarea>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Correct Sequence (comma-separated)</label>
                                <input type="text" class="form-control sequence-correct" required placeholder="Enter the correct sequence, comma-separated" value="${questionData?.correctSequence ? questionData.correctSequence.join(', ') : ''}">
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Audio File (optional)</label>
                                <input type="file" class="form-control sequence-audio" accept="audio/*" onchange="handleSequenceAudioUpload(this)">
                                <div class="audio-preview mt-2" style="display: none;"></div>
                                <input type="hidden" class="audio-file-path">
                                <small class="form-text text-muted">Students can listen to this audio while completing the sequence exercise.</small>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Audio Display Name (optional)</label>
                                <input type="text" class="form-control sequence-audio-display-name" placeholder="e.g. Months of the Year Audio" value="${questionData?.audioDisplayName || ''}">
                            </div>
                        </div>
                    `;
                    break;
            }

            questionHtml += `
                    </div>
                </div>`;
            
            questionsList.insertAdjacentHTML('beforeend', questionHtml);
            console.log('Card inserted for type:', type);
            
            // Get the newly created card
            const card = document.getElementById(questionId);
            
            // Add event listeners for audio file inputs
            const audioInputs = card.querySelectorAll('input[type="file"][accept="audio/*"]');
            audioInputs.forEach(input => {
                input.addEventListener('change', function() {
                    const preview = this.parentElement.querySelector('.audio-preview');
                    const audioFilePathInput = this.parentElement.querySelector('.audio-file-path');
                    
                    if (preview && this.files && this.files.length > 0) {
                        const file = this.files[0];
                        // Create audio element
                        preview.style.display = 'block';
                        preview.innerHTML = `
                            <audio controls class="w-100">
                                <source src="${URL.createObjectURL(file)}" type="${file.type}">
                                Your browser does not support the audio element.
                            </audio>
                            <p class="text-muted small mt-1">${file.name}</p>
                        `;
                        
                        // Upload the audio file to server and store path
                        uploadAssignmentAudio(file, audioFilePathInput);
                    }
                });
            });

            // Populate fields if questionData is provided
            if (questionData) {
                try {
                    console.log('Populating question data:', questionData);
                    
                    // For drag-and-drop, we need to show the right subtype fields
                    if (type === 'drag-and-drop') {
                        // Get subtype either from the question or from the assessment
                        let subtype = questionData.subtype || document.getElementById('subtype').value;
                        console.log('Drag-and-drop subtype:', subtype);
                        
                        // Show only the selected subtype's fields
                        const cardBody = card.querySelector('.card-body');
                        if (cardBody) {
                            // Hide all fields first
                            cardBody.querySelectorAll('.dragdrop-sequence-fields, .dragdrop-fillblank-fields, .dragdrop-image-fillblank-fields, .dragdrop-matching-fields, .dragdrop-long-paragraph-fields')
                                .forEach(el => el.style.display = 'none');
                            
                            // Show only the selected subtype's fields
                            switch (subtype) {
                                case 'sequence':
                                    cardBody.querySelector('.dragdrop-sequence-fields').style.display = 'block';
                                    break;
                                case 'fill-in-blank':
                                    cardBody.querySelector('.dragdrop-fillblank-fields').style.display = 'block';
                                    break;
                                case 'image-fill-blank':
                                    cardBody.querySelector('.dragdrop-image-fillblank-fields').style.display = 'block';
                                    break;
                                case 'long-paragraph-fill-in-blank':
                                    cardBody.querySelector('.dragdrop-long-paragraph-fields').style.display = 'block';
                                    break;
                                case 'matching':
                                    cardBody.querySelector('.dragdrop-matching-fields').style.display = 'block';
                                    break;
                            }
                            
                            // Populate fields based on subtype
                            if (subtype === 'long-paragraph-fill-in-blank') {
                                const paragraphText = questionData.text || '';
                                const wordBank = questionData.wordBank || [];
                                const answers = questionData.answers || [];
                                const extraWords = questionData.extraWords || [];
                                
                                const textArea = cardBody.querySelector('.long-paragraph-text');
                                const wordBankInput = cardBody.querySelector('.long-paragraph-wordbank');
                                const answersInput = cardBody.querySelector('.long-paragraph-answers');
                                const extraInput = cardBody.querySelector('.long-paragraph-extra');
                                
                                // Handle audio display name if present
                                const audioDisplayNameInput = cardBody.querySelector('.long-paragraph-audio-display-name');
                                if (audioDisplayNameInput && questionData.audioDisplayName) {
                                    audioDisplayNameInput.value = questionData.audioDisplayName;
                                }
                                
                                // If there's an audio path, display it
                                if (questionData.audioPath) {
                                    const audioFilePathInput = cardBody.querySelector('.audio-file-path');
                                    const audioPreview = cardBody.querySelector('.audio-preview');
                                    if (audioFilePathInput) audioFilePathInput.value = questionData.audioPath;
                                    if (audioPreview) {
                                        audioPreview.style.display = 'block';
                                        audioPreview.innerHTML = `
                                            <audio controls class="w-100">
                                                <source src="${questionData.audioPath}" type="audio/mpeg">
                                                Your browser does not support the audio element.
                                            </audio>
                                            <p class="text-muted small mt-1">${questionData.audioDisplayName || 'Audio file'}</p>
                                        `;
                                    }
                                }
                                
                                if (textArea) textArea.value = paragraphText;
                                if (wordBankInput) wordBankInput.value = Array.isArray(wordBank) ? wordBank.join(', ') : wordBank;
                                if (answersInput) answersInput.value = Array.isArray(answers) ? answers.join(', ') : answers;
                                if (extraInput) extraInput.value = Array.isArray(extraWords) ? extraWords.join(', ') : extraWords;
                            }
                            
                            // Add other subtypes handling as needed...
                        }
                    }
                    
                    // Add handling for other question types as needed
                    
                } catch (error) {
                    console.error('Error populating question data:', error);
                }
            } else if (type === 'drag-and-drop') {
                // If no question data is provided, but it's a drag-and-drop question,
                // we still need to show the right subtype fields based on the current selection
                const cardBody = card.querySelector('.card-body');
                const subtype = document.getElementById('subtype').value;
                console.log('New drag-and-drop question with subtype:', subtype);
                
                if (cardBody) {
                    // Hide all fields first
                    cardBody.querySelectorAll('.dragdrop-sequence-fields, .dragdrop-fillblank-fields, .dragdrop-image-fillblank-fields, .dragdrop-matching-fields, .dragdrop-long-paragraph-fields')
                        .forEach(el => el.style.display = 'none');
                    
                    // Show only the selected subtype's fields
                    switch (subtype) {
                        case 'sequence':
                            cardBody.querySelector('.dragdrop-sequence-fields').style.display = 'block';
                            break;
                        case 'fill-in-blank':
                            cardBody.querySelector('.dragdrop-fillblank-fields').style.display = 'block';
                            break;
                        case 'image-fill-blank':
                            cardBody.querySelector('.dragdrop-image-fillblank-fields').style.display = 'block';
                            break;
                        case 'long-paragraph-fill-in-blank':
                            cardBody.querySelector('.dragdrop-long-paragraph-fields').style.display = 'block';
                            break;
                        case 'matching':
                            cardBody.querySelector('.dragdrop-matching-fields').style.display = 'block';
                            break;
                    }
                }
            }
        }

        function removeQuestion(questionId) {
            document.getElementById(questionId).remove();
        }

        function addChoice(questionId) {
            const choicesContainer = document.querySelector(`#${questionId} .choices-container`);
            const choiceCount = choicesContainer.querySelectorAll('.input-group').length + 1;
            
            const choiceHtml = `
                <div class="mb-2">
                    <div class="input-group">
                        <div class="input-group-text">
                            <input type="radio" name="correct_${questionId}" required>
                        </div>
                        <input type="text" class="form-control" placeholder="Choice ${choiceCount}" required>
                        <button type="button" class="btn btn-outline-danger" onclick="removeChoice(this)">
                            <i class="bi bi-dash"></i>
                        </button>
                    </div>
                </div>`;
            
            choicesContainer.insertBefore(
                new DOMParser().parseFromString(choiceHtml, 'text/html').body.firstChild,
                choicesContainer.lastElementChild
            );
        }

        function removeChoice(button) {
            const choiceContainer = button.closest('.choices-container');
            if (choiceContainer.querySelectorAll('.input-group').length > 1) {
                button.closest('.mb-2').remove();
            }
        }

        async function handleAudioUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/assessments/upload-audio', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    const audioPreview = input.nextElementSibling;
                    const audioUrl = input.nextElementSibling.nextElementSibling;
                    
                    audioPreview.src = data.filePath;
                    audioPreview.style.display = 'block';
                    audioUrl.value = data.filePath;
                } else {
                    alert('Failed to upload audio file');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to upload audio file');
            }
        }

        // Load existing assessments when page loads
        async function loadExistingAssessments(subjectId = null) {
            try {
                let url;
                // Choose the appropriate endpoint based on filter
                if (subjectId) {
                    url = `/api/subjects/${subjectId}/assessments`;
                } else {
                    url = '/api/teacher/assessments';
                }
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch assessments');
                }

                const assessments = await response.json();
                const container = document.getElementById('existingAssessments');
                container.innerHTML = ''; // Clear existing content
                
                // If filtering by subject, add a header
                if (subjectId) {
                    const subjectName = document.getElementById('subjectSelect').selectedOptions[0]?.text || "Selected subject";
                    container.innerHTML = `
                        <div class="alert alert-info mb-3">
                            <i class="bi bi-filter"></i> Showing assessments for: ${subjectName}
                            <button type="button" class="btn btn-sm btn-outline-primary float-end" onclick="loadExistingAssessments()">
                                Show All
                            </button>
                        </div>
                    `;
                }
                
                // If no assessments after filtering
                if (assessments.length === 0) {
                    container.innerHTML += `
                        <div class="alert alert-warning">
                            <i class="bi bi-exclamation-triangle"></i>
                            ${subjectId ? 'No assessments found for this subject.' : 'No assessments found.'}
                        </div>
                    `;
                    return;
                }

                // No additional filtering needed - backend has already filtered
                assessments.forEach(assessment => {
                    const col = document.createElement('div');
                    col.className = 'col-12 col-md-6 col-xl-3'; // 4 columns on xl screens
                    const card = document.createElement('div');
                    card.className = 'card h-100';
                    card.innerHTML = `
                        <div class="card-body">
                            <h6 class="card-title">
                                ${assessment.title}
                                ${assessment.unattached ? '<span class="badge bg-danger ms-2">Unattached</span>' : ''}
                            </h6>
                            <p class="card-text small">
                                ${assessment.section.part.unit.subject.name} > 
                                ${assessment.section.part.unit.name} > 
                                ${assessment.section.part.name} > 
                                ${assessment.section.name}
                            </p>
                            <p class="card-text small">
                                Category: ${assessment.category || 'N/A'}
                            </p>
                            <p class="card-text small">
                                Questions: ${assessment.questions.length}
                            </p>
                            <div class="btn-group">
                                <button class="btn btn-sm btn-secondary" onclick="openAssessmentView('${assessment.id}')">
                                    <i class="bi bi-eye"></i> View
                                </button>
                                <button class="btn btn-sm btn-primary" onclick="editAssessment('${assessment.id}')">
                                    <i class="bi bi-pencil"></i> Edit
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="deleteAssessment('${assessment.id}')">
                                    <i class="bi bi-trash"></i> Delete
                                </button>
                                ${['speaking', 'assignment', 'writing', 'writing-long'].includes((assessment.type || '').toLowerCase()) ? `<a href="/teacher/grade-assessment.html?assessmentId=${assessment.id}" class="btn btn-success btn-sm ms-2"><i class="bi bi-clipboard-check"></i> Grade</a>` : ''}
                            </div>
                        </div>
                    `;
                    col.appendChild(card);
                    container.appendChild(col);
                });
            } catch (error) {
                console.error('Error loading assessments:', error);
                alert('Failed to load existing assessments');
            }
        }

        async function editAssessment(assessmentId) {
            try {
                const response = await fetch(`/api/assessments/${assessmentId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to fetch assessment');
                }

                const assessment = await response.json();
                console.log('Editing assessment:', assessment);

                // Populate form fields
                document.getElementById('title').value = assessment.title || '';
                document.getElementById('description').value = assessment.description || '';
                document.getElementById('type').value = assessment.type || 'multiple-choice';
                
                // Handle subtype for drag-and-drop
                if (assessment.type === 'drag-and-drop') {
                    document.getElementById('subtypeContainer').style.display = 'block';
                    // Set the subtype if it exists at the top level or in the first question
                    let subtype = assessment.subtype;
                    if (!subtype && assessment.questions && assessment.questions.length > 0) {
                        subtype = assessment.questions[0].subtype;
                    }
                    if (subtype) {
                        document.getElementById('subtype').value = subtype;
                    }
                } else {
                    document.getElementById('subtypeContainer').style.display = 'none';
                }
                
                // Trigger the type change event to set up the form correctly
                handleTypeChange();
                updateQuestionOptions();
                
                // Load and display any existing audio files
                const audioPreview = document.getElementById('audioPreview');
                const audioUrl = document.getElementById('audioUrl');
                
                // Check if there are any audio media files
                if (assessment.mediaFiles && assessment.mediaFiles.length > 0) {
                    // Find audio files
                    const audioFiles = assessment.mediaFiles.filter(file => 
                        file.type && file.type.startsWith('audio/'));
                    
                    if (audioFiles.length > 0) {
                        // Use the first audio file
                        const audioFile = audioFiles[0];
                        audioPreview.src = audioFile.filePath;
                        audioPreview.style.display = 'block';
                        audioUrl.value = audioFile.filePath;
                        
                        // Show feedback that audio is already uploaded
                        const audioContainer = document.getElementById('audioUploadContainer');
                        // Remove any previous feedback
                        const oldFeedback = audioContainer.querySelector('.upload-feedback');
                        if (oldFeedback) oldFeedback.remove();
                        
                        // Add new feedback
                        const feedbackDiv = document.createElement('div');
                        feedbackDiv.className = 'alert alert-info mt-2 upload-feedback';
                        feedbackDiv.innerHTML = `<strong>Audio File:</strong> This assessment already has an audio file attached.`;
                        audioContainer.querySelector('.card-body').appendChild(feedbackDiv);
                    }
                }
                
                if (assessment.dueDate) {
                    document.getElementById('dueDate').value = new Date(assessment.dueDate).toISOString().slice(0, 16);
                } else {
                    document.getElementById('dueDate').value = '';
                }
                
                // Set max attempts
                document.getElementById('maxAttempts').value = assessment.maxAttempts || '';
                
                // Set criteria
                document.getElementById('criteria').value = assessment.criteria || '';
                
                // Set Skill/Category
                document.getElementById('assessmentCategory').value = assessment.category || '';

                // Set section selectors
                await setSelectors(assessment.section);

                // Clear existing questions
                document.getElementById('questionsList').innerHTML = '';

                // Add existing questions 
                if (Array.isArray(assessment.questions) && assessment.questions.length > 0) {
                    for (const question of assessment.questions) {
                        console.log('Adding question:', question);
                        addQuestion(question.type || assessment.type, question);
                    }
                } else if (assessment.type === 'drag-and-drop' && assessment.subtype === 'long-paragraph-fill-in-blank') {
                    // Special case: Sometimes drag-and-drop questions are stored at the assessment level
                    // Create a synthetic question from the assessment properties
                    const syntheticQuestion = {
                        type: 'drag-and-drop',
                        subtype: assessment.subtype,
                        text: assessment.text || '',
                        wordBank: assessment.wordBank || [],
                        answers: assessment.answers || [],
                        extraWords: assessment.extraWords || []
                    };
                    addQuestion('drag-and-drop', syntheticQuestion);
                }

                // Store assessment ID for update
                document.getElementById('assessmentForm').dataset.assessmentId = assessmentId;

                // Show Save button, hide Create button
                showEditMode();

                // Scroll to form
                document.querySelector('.card-header').scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                console.error('Error loading assessment:', error);
                alert('Failed to load assessment for editing: ' + error.message);
            }
        }

        // Save Changes button logic
        document.getElementById('saveAssessmentBtn').addEventListener('click', async function() {
            const form = document.getElementById('assessmentForm');
            const assessmentId = form.dataset.assessmentId;
            if (!assessmentId) {
                alert('No assessment selected for editing.');
                return;
            }
            // Gather form data (similar to submit handler)
            const formData = new FormData(form);
            // Add questions as JSON string
            // (You may need to gather questions from the UI as in your submit handler)
            // For simplicity, let's call getDragAndDropQuestions, getMultipleChoiceQuestions, etc. as needed
            const type = document.getElementById('type').value;
            let questions = [];
            if (type === 'multiple-choice') {
                questions = getMultipleChoiceQuestions();
            } else if (type === 'true-false') {
                questions = getTrueFalseQuestions();
            } else if (type === 'drag-and-drop') {
                const subtype = document.getElementById('subtype').value;
                questions = getDragAndDropQuestions(subtype);
            } else if (type === 'matching') {
                questions = getMatchingQuestions();
            } else if (type === 'change-sequence') {
                // Gather all change-sequence question cards
                const questionCards = document.querySelectorAll('.question-card[data-type="change-sequence"]');
                questions = Array.from(questionCards).map(card => getQuestionData(card));
            }
            formData.set('questions', JSON.stringify(questions));
            // Add subtype if drag-and-drop
            if (type === 'drag-and-drop') {
                const subtypeValue = document.getElementById('subtype').value;
                formData.set('subtype', subtypeValue);
                // Also set subtype in all drag-and-drop questions
                if (questions && questions.length > 0) {
                    questions.forEach(q => { q.subtype = subtypeValue; });
                    formData.set('questions', JSON.stringify(questions));
                }
            }
            // Add category field
            const categoryValue = document.getElementById('assessmentCategory').value;
            console.log('Category value:', categoryValue);
            formData.set('category', categoryValue);
            // Add maxAttempts if set
            const maxAttemptsValue = document.getElementById('maxAttempts').value;
            if (maxAttemptsValue) {
                formData.append('maxAttempts', maxAttemptsValue);
            }
            // Log form data for debugging
            for (let pair of formData.entries()) {
                console.log(pair[0] + ': ' + pair[1]);
            }
            // Send PUT request to update assessment
            try {
                const response = await fetch(`/api/assessments/${assessmentId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                if (response.ok) {
                    alert('Assessment updated successfully!');
                    // Reset form and switch to create mode
                    form.reset();
                    document.getElementById('questionsList').innerHTML = '';
                    showCreateMode();
                    await loadExistingAssessments();
                } else {
                    const error = await response.json();
                    alert('Error updating assessment: ' + (error.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error updating assessment:', error);
                alert('Failed to update assessment. Please try again.');
            }
        });

        async function setSelectors(section) {
            // Set subject
            const subjectSelect = document.getElementById('subjectSelect');
            subjectSelect.value = section.part.unit.subject.id;
            await loadUnits(section.part.unit.subject.id);

            // Set unit
            const unitSelect = document.getElementById('unitSelect');
            unitSelect.value = section.part.unit.id;
            await loadParts(section.part.unit.id);

            // Set part
            const partSelect = document.getElementById('partSelect');
            partSelect.value = section.part.id;
            await loadSections(section.part.id);

            // Set section
            const sectionSelect = document.getElementById('sectionSelect');
            sectionSelect.value = section.id;
        }

        // Modify form submission to handle both create and update
        document.getElementById('assessmentForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Validate title field is present
            const titleField = document.getElementById('title');
            if (!titleField || !titleField.value.trim()) {
                alert('Title is required');
                if (titleField) titleField.focus();
                return;
            }
            
            // Get current assessment type and subtype
            const type = document.getElementById('type').value;
            const subtype = document.getElementById('subtype') ? document.getElementById('subtype').value : null;
            
            // Validate drag-and-drop long paragraph fields before submission
            if (type === 'drag-and-drop' && subtype === 'long-paragraph-fill-in-blank') {
                const validationPassed = validateDragAndDropFields();
                if (!validationPassed) return;
            }
            
            // Gather questions based on type
            let questions = [];
            if (type === 'multiple-choice') {
                questions = getMultipleChoiceQuestions();
            } else if (type === 'true-false') {
                questions = getTrueFalseQuestions();
            } else if (type === 'drag-and-drop') {
                questions = getDragAndDropQuestions(subtype);
            } else if (type === 'matching') {
                questions = getMatchingQuestions();
            } else if (type === 'change-sequence') {
                const questionCards = document.querySelectorAll('.question-card[data-type="change-sequence"]');
                questions = Array.from(questionCards).map(card => getQuestionData(card));
            } else if (type === 'writing') {
                // Add writing question gathering if needed
            }
            // ... add other types as needed ...

            // Build form data
            const formData = new FormData();
            formData.append('title', document.getElementById('title').value);
            formData.append('type', type);
            formData.append('description', document.getElementById('description').value);
            formData.append('dueDate', document.getElementById('dueDate').value);
            formData.append('criteria', document.getElementById('criteria').value);
            formData.set('category', document.getElementById('assessmentCategory').value);
            formData.append('quarter', document.getElementById('quarter').value);
            const maxAttemptsValue = document.getElementById('maxAttempts').value;
            if (maxAttemptsValue) {
                formData.append('maxAttempts', maxAttemptsValue);
            }
            if (type === 'drag-and-drop' && subtype) {
                formData.append('subtype', subtype);
                // Also set subtype in all drag-and-drop questions
                if (questions && questions.length > 0) {
                    questions.forEach(q => { q.subtype = subtype; });
                }
            }
            formData.set('questions', JSON.stringify(questions));
            // Audio file handling
            const audioUrl = document.getElementById('audioUrl') ? document.getElementById('audioUrl').value : '';
            if (audioUrl) {
                // Add as a field for backend to add to mediaFiles
                formData.append('audioFile', audioUrl);
            }
            // Section ID
            const sectionId = document.getElementById('sectionSelect').value;
            if (!sectionId) {
                alert('Please select a section.');
                return;
            }
            // Show loading state
            const submitBtn = document.querySelector('#assessmentForm button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
            // Send request
            try {
                const response = await fetch(`/api/sections/${sectionId}/assessments`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                if (response.ok) {
                    alert('Assessment created successfully!');
                    document.getElementById('assessmentForm').reset();
                    clearQuestionsUi();
                    loadExistingAssessments();
                } else {
                    const error = await response.json();
                    alert(`Failed to create assessment: ${error.error || error.message || 'Unknown error'}`);
                }
            } catch (error) {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                console.error('Error creating assessment:', error);
                alert(`Error creating assessment: ${error.message}`);
            }
        });

        function bulkImportMatchingPairs(questionId) {
            // Create a modal for bulk import
            const modalId = `bulkImportModal-${Date.now()}`;
            
            const modalHtml = `
            <div class="modal fade" id="${modalId}" tabindex="-1" aria-labelledby="${modalId}-label" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="${modalId}-label">Bulk Import Matching Pairs</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="alert alert-info">
                                <p><strong>Instructions:</strong> Paste your matching pairs in one of these formats:</p>
                                <ul>
                                    <li>One pair per line with expressions and meanings separated by tab, comma, or pipe (|).</li>
                                    <li>Or in two columns copied from a spreadsheet.</li>
                                </ul>
                                <p>Example:</p>
                                <pre>Weird!|That's strange.
I hope so.|I want that to happen.
Ooh, exciting!|That sounds fun.</pre>
                            </div>
                            <div class="form-group">
                                <label for="bulkPairsInput" class="form-label">Paste your pairs below:</label>
                                <textarea class="form-control" id="bulkPairsInput" rows="10" placeholder="Expression1|Meaning1&#10;Expression2|Meaning2&#10;Expression3|Meaning3"></textarea>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" id="importPairsBtn">Import Pairs</button>
                        </div>
                    </div>
                </div>
            </div>`;
            
            // Add modal to the body
            const modalDiv = document.createElement('div');
            modalDiv.innerHTML = modalHtml;
            document.body.appendChild(modalDiv);
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById(modalId));
            modal.show();
            
            // Add event listener for the import button
            document.getElementById('importPairsBtn').addEventListener('click', function() {
                const bulkInput = document.getElementById('bulkPairsInput').value.trim();
                if (!bulkInput) {
                    alert('Please paste some content to import.');
                    return;
                }
                
                // First split by lines
                const lines = bulkInput.split(/\r?\n/).filter(line => line.trim() !== '');
                const pairs = [];
                
                lines.forEach(line => {
                    // Try different delimiters
                    let parts;
                    if (line.includes('|')) {
                        parts = line.split('|');
                    } else if (line.includes('\t')) {
                        parts = line.split('\t');
                    } else if (line.includes(',')) {
                        parts = line.split(',');
                    } else {
                        // If no delimiter is found, skip this line
                        console.warn('No delimiter found in line:', line);
                        return;
                    }
                    
                    if (parts.length >= 2) {
                        pairs.push({
                            expression: parts[0].trim(),
                            meaning: parts[1].trim()
                        });
                    }
                });
                
                if (pairs.length === 0) {
                    alert('No valid pairs found. Please check your input format.');
                    return;
                }
                
                // Clear existing pairs (except the first one if it's empty)
                const matchingPairsContainer = document.querySelector(`#${questionId} .matching-pairs`);
                const existingPairs = Array.from(matchingPairsContainer.querySelectorAll('.matching-pair'));
                
                // Keep only the first pair if it's empty
                const firstPairExpressionInput = existingPairs[0]?.querySelector('input[placeholder="Enter expression"]');
                const firstPairMeaningInput = existingPairs[0]?.querySelector('input[placeholder="Enter meaning"]');
                const isFirstPairEmpty = firstPairExpressionInput && firstPairMeaningInput && 
                                        !firstPairExpressionInput.value.trim() && 
                                        !firstPairMeaningInput.value.trim();
                
                // Remove all existing pairs except potentially the first one
                existingPairs.forEach((pair, index) => {
                    if (index === 0 && isFirstPairEmpty) {
                        // Keep the first pair if it's empty
                        return;
                    }
                    pair.remove();
                });
                
                // If we kept the first pair, update it with the first imported pair
                if (isFirstPairEmpty && pairs.length > 0) {
                    firstPairExpressionInput.value = pairs[0].expression;
                    firstPairMeaningInput.value = pairs[0].meaning;
                    pairs.shift(); // Remove the first pair since we've added it
                }
                
                // Add the remaining pairs
                pairs.forEach(pair => {
                    const newPair = document.createElement('div');
                    newPair.className = 'matching-pair';
                    newPair.innerHTML = `
                        <div class="row mb-2">
                            <div class="col-md-5">
                                <input type="text" class="form-control" name="expression_${questionId}_${pairs.length}" placeholder="Enter expression" value="${pair.expression}" required>
                            </div>
                            <div class="col-md-5">
                                <input type="text" class="form-control" name="meaning_${questionId}_${pairs.length}" placeholder="Enter meaning" value="${pair.meaning}" required>
                            </div>
                            <div class="col-md-2">
                                <button type="button" class="btn btn-outline-danger" onclick="removeMatchingPair(this)">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>`;
                    matchingPairsContainer.appendChild(newPair);
                });
                
                modal.hide();
            });
            
            // Add event listener to remove modal from DOM when hidden
            document.getElementById(modalId).addEventListener('hidden.bs.modal', function() {
                this.remove();
            });
        }

        window.toggleTfButton = function(btn) {
            const states = ["", "T", "F"];
            let idx = states.indexOf(btn.dataset.state || "");
            idx = (idx + 1) % states.length;
            btn.dataset.state = states[idx];
            btn.textContent = states[idx] || "?";
            btn.classList.toggle('btn-success', states[idx] === 'T');
            btn.classList.toggle('btn-danger', states[idx] === 'F');
            btn.classList.toggle('btn-outline-secondary', states[idx] === '');
        };
        window.addTfSentence = function(btn) {
            const container = btn.closest('.card-body').querySelector('.true-false-sentences');
            const row = document.createElement('div');
            row.className = 'tf-sentence-row mb-2 d-flex align-items-center';
            row.innerHTML = `<input type="text" class="form-control me-2" placeholder="Enter sentence" required style="max-width: 70%"><button type="button" class="btn btn-outline-secondary tf-toggle" data-state="" onclick="toggleTfButton(this)">?</button><button type="button" class="btn btn-outline-danger ms-2" onclick="removeTfSentence(this)"><i class="bi bi-trash"></i></button>`;
            container.appendChild(row);
        };
        window.removeTfSentence = function(btn) {
            btn.closest('.tf-sentence-row').remove();
        };

        function toggleResponseType(select) {
            const questionCard = select.closest('.card');
            const timeLimitInput = questionCard.querySelector('input[type="number"]');
            const maxValue = select.value === 'video' ? 300 : 180; // 5 minutes for video, 3 minutes for audio
            timeLimitInput.max = maxValue;
            if (parseInt(timeLimitInput.value) > maxValue) {
                timeLimitInput.value = maxValue;
            }
        }

        window.toggleDragDropSubtypeFields = function(select) {
            const cardBody = select.closest('.card-body');
            if (!cardBody) return;
            
            const seqFields = cardBody.querySelector('.dragdrop-sequence-fields');
            const fillFields = cardBody.querySelector('.dragdrop-fillblank-fields');
            const imageFillFields = cardBody.querySelector('.dragdrop-image-fillblank-fields');
            const matchingFields = cardBody.querySelector('.dragdrop-matching-fields');
            const longParagraphFields = cardBody.querySelector('.dragdrop-long-paragraph-fields');
            
            // Helper to set required on all inputs in a section
            function setRequired(section, required) {
                if (!section) return;
                section.querySelectorAll('input, textarea, select').forEach(input => {
                    // Do not set required for audio file input or audio display name in sequence subtype
                    if (input.classList.contains('sequence-audio') || input.classList.contains('sequence-audio-display-name')) {
                        input.required = false;
                    } else {
                        input.required = required;
                    }
                });
            }

            // Hide all fields and remove required
            if (seqFields) {
                seqFields.style.display = 'none';
                setRequired(seqFields, false);
            }
            if (fillFields) {
                fillFields.style.display = 'none';
                setRequired(fillFields, false);
            }
            if (imageFillFields) {
                imageFillFields.style.display = 'none';
                setRequired(imageFillFields, false);
            }
            if (matchingFields) {
                matchingFields.style.display = 'none';
                setRequired(matchingFields, false);
            }
            if (longParagraphFields) {
                longParagraphFields.style.display = 'none';
                setRequired(longParagraphFields, false);
            }
            
            // Show the selected type and set required only for visible fields
            switch (select.value) {
                case 'sequence':
                    if (seqFields) {
                        seqFields.style.display = 'block';
                        setRequired(seqFields, true);
                    }
                    break;
                case 'fill-in-blank':
                    if (fillFields) {
                        fillFields.style.display = 'block';
                        setRequired(fillFields, true);
                    }
                    break;
                case 'image-fill-blank':
                    if (imageFillFields) {
                        imageFillFields.style.display = 'block';
                        setRequired(imageFillFields, true);
                    }
                    break;
                case 'long-paragraph-fill-in-blank':
                    if (longParagraphFields) {
                        longParagraphFields.style.display = 'block';
                        setRequired(longParagraphFields, true);
                    }
                    break;
                case 'matching':
                    if (matchingFields) {
                        matchingFields.style.display = 'block';
                        setRequired(matchingFields, true);
                    }
                    break;
            }
        }

        window.addFillBlankSentence = function(btn) {
            const list = btn.closest('.fillblank-sentences-list') || btn.parentElement.querySelector('.fillblank-sentences-list');
            const idx = list.children.length;
            const row = document.createElement('div');
            row.className = 'fillblank-sentence-row mb-2';
            row.innerHTML = `
                <input type="text" class="form-control d-inline-block me-2" style="width:60%" placeholder="Type sentence, use [BLANK] for blank(s)" required>
                <input type="text" class="form-control d-inline-block me-2" style="width:30%" placeholder="Correct answer(s), comma-separated" required>
                <button type="button" class="btn btn-outline-danger btn-sm" onclick="this.parentElement.remove()"><i class="bi bi-trash"></i></button>
            `;
            list.appendChild(row);
        };

        // Add modal HTML at the end of <body> if not already present
        if (!document.getElementById('bulkImportFillBlankModal')) {
            const modalHtml = `
            <div class="modal fade" id="bulkImportFillBlankModal" tabindex="-1" aria-labelledby="bulkImportFillBlankModalLabel" aria-hidden="true">
              <div class="modal-dialog">
                <div class="modal-content">
                  <div class="modal-header">
                    <h5 class="modal-title" id="bulkImportFillBlankModalLabel">Bulk Import Sentences (JSON)</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                  </div>
                  <div class="modal-body">
                    <div class="mb-3">
                      <label for="bulkFillBlankJson" class="form-label">Paste JSON array of sentences:</label>
                      <textarea class="form-control" id="bulkFillBlankJson" rows="8" placeholder='[
  { "text": "I am [BLANK] today.", "answers": ["happy"] },\n  { "text": "She is [BLANK] and [BLANK]", "answers": ["tired", "hungry"] }
]'></textarea>
                      <div class="form-text">Each item should have a <code>text</code> and <code>answers</code> array.</div>
                    </div>
                    <div id="bulkImportFillBlankError" class="text-danger mb-2"></div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="importFillBlankBtn">Import</button>
                  </div>
                </div>
              </div>
            </div>`;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // Handle import button click
        if (!window._bulkImportFillBlankHandlerAdded) {
            document.getElementById('importFillBlankBtn').addEventListener('click', function() {
                const textarea = document.getElementById('bulkFillBlankJson');
                const errorDiv = document.getElementById('bulkImportFillBlankError');
                let data;
                try {
                    data = JSON.parse(textarea.value);
                } catch (e) {
                    errorDiv.textContent = 'Invalid JSON.';
                    return;
                }
                if (!Array.isArray(data.questions)) {
                    errorDiv.textContent = 'JSON must be an array.';
                    return;
                }
                // Validate and add to UI
                const fillFields = window._currentFillBlankFields;
                const list = fillFields.querySelector('.fillblank-sentences-list');
                list.innerHTML = '';
                let valid = true;
                data.questions.forEach(item => {
                    if (!item.text || !Array.isArray(item.answers) || item.answers.length === 0) {
                        valid = false;
                    }
                });
                if (!valid) {
                    errorDiv.textContent = 'Each item must have a text and a non-empty answers array.';
                    return;
                }
                // Add to UI
                data.questions.forEach(item => {
                    const row = document.createElement('div');
                    row.className = 'fillblank-sentence-row mb-2';
                    row.innerHTML = `
                        <input type="text" class="form-control d-inline-block me-2" style="width:60%" placeholder="Type sentence, use [BLANK] for blank(s)" required value="${item.text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}">
                        <input type="text" class="form-control d-inline-block me-2" style="width:30%" placeholder="Correct answer(s), comma-separated" required value="${item.answers.join(', ')}">
                        <button type="button" class="btn btn-outline-danger btn-sm" onclick="this.parentElement.remove()"><i class="bi bi-trash"></i></button>
                    `;
                    list.appendChild(row);
                });
                // Hide modal
                bootstrap.Modal.getInstance(document.getElementById('bulkImportFillBlankModal')).hide();
            });
            window._bulkImportFillBlankHandlerAdded = true;
        }

        window.showBulkImportFillBlankModal = function(btn) {
            // Find the closest .dragdrop-fillblank-fields
            const fillFields = btn.closest('.dragdrop-fillblank-fields');
            // Store a reference for later
            window._currentFillBlankFields = fillFields;
            // Clear textarea and error
            document.getElementById('bulkFillBlankJson').value = '';
            document.getElementById('bulkImportFillBlankError').textContent = '';
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('bulkImportFillBlankModal'));
            modal.show();
        };

        // Add modal HTML at the end of <body> if not already present
        if (!document.getElementById('bulkImportWritingModal')) {
            const modalHtml = `
            <div class="modal fade" id="bulkImportWritingModal" tabindex="-1" aria-labelledby="bulkImportWritingModalLabel" aria-hidden="true">
              <div class="modal-dialog">
                <div class="modal-content">
                  <div class="modal-header">
                    <h5 class="modal-title" id="bulkImportWritingModalLabel">Bulk Import Writing Questions</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                  </div>
                  <div class="modal-body">
                    <div class="mb-3">
                      <label for="bulkWritingInput" class="form-label">Paste questions and answers (one per line, separated by a pipe |):</label>
                      <textarea class="form-control" id="bulkWritingInput" rows="8" placeholder="What is the capital of France? | Paris\nWho wrote Hamlet? | Shakespeare\n2 + 2 = ? | 4"></textarea>
                      <div class="form-text">Each line: <code>Question | Answer</code></div>
                    </div>
                    <div id="bulkImportWritingError" class="text-danger mb-2"></div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="importWritingBtn">Import</button>
                  </div>
                </div>
              </div>
            </div>`;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // Add handler for import button
        if (!window._bulkImportWritingHandlerAdded) {
            document.getElementById('importWritingBtn').addEventListener('click', function() {
                const textarea = document.getElementById('bulkWritingInput');
                const errorDiv = document.getElementById('bulkImportWritingError');
                const lines = textarea.value.split(/\r?\n/).filter(line => line.trim() !== '');
                if (!lines.length) {
                    errorDiv.textContent = 'Please enter at least one question.';
                    return;
                }
                let valid = true;
                const questions = lines.map(line => {
                    const parts = line.split('|');
                    if (parts.length < 2) { valid = false; }
                    return {
                        text: parts[0] ? parts[0].trim() : '',
                        correctAnswer: parts[1] ? parts[1].trim() : ''
                    };
                });
                if (!valid) {
                    errorDiv.textContent = 'Each line must have a question and an answer separated by a pipe (|).';
                    return;
                }
                // Add to UI
                const questionsList = document.getElementById('questionsList');
                questions.forEach(q => {
                    const questionId = 'question_' + Date.now() + Math.floor(Math.random()*10000);
                    let questionHtml = `
                        <div class="card mb-3" id="${questionId}">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <h6 class="mb-0">Writing Question</h6>
                                <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeQuestion('${questionId}')">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                            <div class="card-body">
                                <div class="mb-3">
                                    <label class="form-label">Question</label>
                                    <input type="text" class="form-control" value="${q.text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}" required>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Correct Answer</label>
                                    <input type="text" class="form-control" value="${q.correctAnswer.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}" required>
                                </div>
                            </div>
                        </div>`;
                    questionsList.insertAdjacentHTML('beforeend', questionHtml);
                });
                // Hide modal
                bootstrap.Modal.getInstance(document.getElementById('bulkImportWritingModal')).hide();
            });
            window._bulkImportWritingHandlerAdded = true;
        }

        window.showBulkImportWritingModal = function() {
            document.getElementById('bulkWritingInput').value = '';
            document.getElementById('bulkImportWritingError').textContent = '';
            const modal = new bootstrap.Modal(document.getElementById('bulkImportWritingModal'));
            modal.show();
        };

        async function handleBulkImport() {
            const fileInput = document.getElementById('bulkImportFile');
            const errorDiv = document.getElementById('bulkImportError');
            errorDiv.style.display = 'none';
            if (!fileInput.files.length) {
                errorDiv.textContent = 'Please select a JSON file.';
                errorDiv.style.display = '';
                return;
            }
            const file = fileInput.files[0];
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                if (!Array.isArray(data.questions)) {
                    throw new Error('Invalid format: missing questions array.');
                }
                data.questions.forEach(q => {
                    if (q.type !== 'multiple-choice' || !q.text || !Array.isArray(q.options) || typeof q.correctAnswer !== 'number') {
                        throw new Error('Invalid question format.');
                    }
                    addMultipleChoiceQuestion(q.text, q.options, q.correctAnswer);
                });
                alert('Questions imported successfully!');
            } catch (e) {
                errorDiv.textContent = 'Import failed: ' + e.message;
                errorDiv.style.display = '';
            }
        }

        function addMultipleChoiceQuestion(text, options, correctIndex) {
            // Generate a unique questionId
            const questionId = 'question_' + Date.now() + Math.floor(Math.random() * 10000);
            addQuestionWithId('multiple-choice', questionId);
            const card = document.getElementById(questionId);
            if (!card) return;
            card.classList.add('question-card');
            const textInput = card.querySelector('.card-body textarea');
            if (textInput) textInput.value = text;
            const choicesContainer = card.querySelector('.choices-container');
            if (!choicesContainer) {
                alert('Import failed: Could not find choices container in the question card.');
                return;
            }
            let optionInputs = choicesContainer.querySelectorAll('input[type="text"]');
            const addChoiceBtn = choicesContainer.querySelector('.btn-outline-primary');
            let safety = 0;
            while (optionInputs.length < options.length && safety < 10) {
                if (addChoiceBtn) addChoiceBtn.click();
                optionInputs = choicesContainer.querySelectorAll('input[type="text"]');
                safety++;
            }
            options.forEach((opt, i) => {
                if (optionInputs[i]) optionInputs[i].value = opt;
            });
            const correctInputs = choicesContainer.querySelectorAll('input[type="radio"]');
            if (correctInputs[correctIndex]) correctInputs[correctIndex].checked = true;
        }

        // Helper to add a question with a specific ID
        function addQuestionWithId(type, questionId) {
            const questionsList = document.getElementById('questionsList');
            let questionHtml = `
                <div class="card mb-3 question-card" id="${questionId}" data-type="${type}">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">${type.charAt(0).toUpperCase() + type.slice(1)} Question</h6>
                        <button type="button" class="btn btn-outline-danger btn-sm" onclick="removeQuestion('${questionId}')">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                    <div class="card-body">`;
            switch(type) {
                case 'multiple-choice':
                    questionHtml += `
                        <div class="mb-3">
                            <label class="form-label">Question Text</label>
                            <textarea class="form-control" rows="2" required></textarea>
                        </div>
                        <div class="choices-container">
                            <label class="form-label">Choices</label>
                            <div class="mb-2">
                                <div class="input-group">
                                    <div class="input-group-text">
                                        <input type="radio" name="correct_${questionId}" required>
                                    </div>
                                    <input type="text" class="form-control" placeholder="Choice 1" required>
                                    <button type="button" class="btn btn-outline-danger" onclick="removeChoice(this)">
                                        <i class="bi bi-dash"></i>
                                    </button>
                                </div>
                            </div>
                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="addChoice('${questionId}')">
                                <i class="bi bi-plus"></i> Add Choice
                            </button>
                        </div>`;
                    break;
                // ... handle other types if needed ...
            }
            questionHtml += `</div></div>`;
            questionsList.insertAdjacentHTML('beforeend', questionHtml);
        }

        function showPasteJsonModal() {
            document.getElementById('pastedJson').value = '';
            document.getElementById('pasteJsonError').textContent = '';
            const modal = new bootstrap.Modal(document.getElementById('pasteJsonModal'));
            modal.show();
        }

        function handlePasteJsonImport() {
            const text = document.getElementById('pastedJson').value;
            const errorDiv = document.getElementById('pasteJsonError');
            errorDiv.textContent = '';
            try {
                const data = JSON.parse(text);
                if (!Array.isArray(data.questions)) {
                    throw new Error('Invalid format: missing questions array.');
                }
                data.questions.forEach(q => {
                    if (q.type !== 'multiple-choice' || !q.text || !Array.isArray(q.options) || typeof q.correctAnswer !== 'number') {
                        throw new Error('Invalid question format.');
                    }
                    addMultipleChoiceQuestion(q.text, q.options, q.correctAnswer);
                });
                bootstrap.Modal.getInstance(document.getElementById('pasteJsonModal')).hide();
                alert('Questions imported successfully!');
            } catch (e) {
                errorDiv.textContent = 'Import failed: ' + e.message;
            }
        }

        function showBulkImport() {
            document.getElementById('bulkImportContainer').scrollIntoView({behavior: 'smooth'});
            document.getElementById('bulkImportFile').focus();
        }

        function addImageFillBlankPair(button) {
            const pairsList = button.closest('.dragdrop-image-fillblank-fields').querySelector('.image-fillblank-pairs-list');
            const pairIndex = pairsList.children.length;
            
            const pairDiv = document.createElement('div');
            pairDiv.className = 'card mb-3';
            pairDiv.innerHTML = `
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">Pair ${pairIndex + 1}</h6>
                        <button type="button" class="btn btn-outline-danger btn-sm" onclick="this.closest('.card').remove()">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Image</label>
                        <input type="file" class="form-control image-input" accept="image/*" required>
                        <input type="hidden" class="image-server-path">
                        <div class="image-preview mt-2" style="max-width: 200px;"></div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Sentence with Blank</label>
                        <input type="text" class="form-control sentence-input" placeholder="e.g. The boy looks [BLANK]." required>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Correct Answer</label>
                        <input type="text" class="form-control answer-input" placeholder="e.g. happy" required>
                    </div>
                </div>
            `;
            
            // Add image preview and upload functionality
            const imageInput = pairDiv.querySelector('.image-input');
            const previewDiv = pairDiv.querySelector('.image-preview');
            const serverPathInput = pairDiv.querySelector('.image-server-path');
            imageInput.addEventListener('change', async function() {
                if (this.files && this.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        previewDiv.innerHTML = `<img src="${e.target.result}" class="img-fluid">`;
                    };
                    reader.readAsDataURL(this.files[0]);
                    // Upload image to server
                    const formData = new FormData();
                    formData.append('file', this.files[0]);
                    try {
                        const response = await fetch('/api/assessments/upload-audio', { // Use the same endpoint as audio for now
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('token')}`
                            },
                            body: formData
                        });
                        if (response.ok) {
                            const data = await response.json();
                            serverPathInput.value = data.filePath;
                        } else {
                            alert('Failed to upload image.');
                        }
                    } catch (error) {
                        alert('Error uploading image: ' + error.message);
                    }
                }
            });
            
            pairsList.appendChild(pairDiv);
        }

        function showBulkImportImageFillBlankModal(button) {
            const modalHtml = `
                <div class="modal fade" id="bulkImportImageFillBlankModal" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Bulk Import Image-Sentence Pairs</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <p>Enter your image-sentence pairs in JSON format:</p>
                                <textarea class="form-control" rows="10" placeholder='[
    {
        "image": "path/to/image1.jpg",
        "text": "The boy looks [BLANK].",
        "answer": "happy"
    },
    {
        "image": "path/to/image2.jpg",
        "text": "The girl is [BLANK].",
        "answer": "sad"
    }
]'></textarea>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                <button type="button" class="btn btn-primary" onclick="importImageFillBlankPairs(this)">Import</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to document
            const modalDiv = document.createElement('div');
            modalDiv.innerHTML = modalHtml;
            document.body.appendChild(modalDiv);
            
            // Show modal
            const modal = new bootstrap.Modal(modalDiv.querySelector('.modal'));
            modal.show();
            
            // Remove modal from DOM after it's hidden
            modalDiv.querySelector('.modal').addEventListener('hidden.bs.modal', function() {
                modalDiv.remove();
            });
        }

        function importImageFillBlankPairs(button) {
            const modal = button.closest('.modal');
            const textarea = modal.querySelector('textarea');
            const pairsList = document.querySelector('.image-fillblank-pairs-list');
            
            try {
                const pairs = JSON.parse(textarea.value);
                if (!Array.isArray(pairs)) throw new Error('Input must be an array of pairs');
                
                // Clear existing pairs
                pairsList.innerHTML = '';
                
                // Add each pair
                pairs.forEach((pair, index) => {
                    const pairDiv = document.createElement('div');
                    pairDiv.className = 'card mb-3';
                    pairDiv.innerHTML = `
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0">Pair ${index + 1}</h6>
                                <button type="button" class="btn btn-outline-danger btn-sm" onclick="this.closest('.card').remove()">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Image</label>
                                <input type="text" class="form-control image-input" value="${pair.image}" required>
                                <div class="image-preview mt-2" style="max-width: 200px;">
                                    <img src="${pair.image}" class="img-fluid">
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Sentence with Blank</label>
                                <input type="text" class="form-control sentence-input" value="${pair.text}" required>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Correct Answer</label>
                                <input type="text" class="form-control answer-input" value="${pair.answer}" required>
                            </div>
                        </div>
                    `;
                    pairsList.appendChild(pairDiv);
                });
                
                // Close modal
                bootstrap.Modal.getInstance(modal).hide();
            } catch (error) {
                alert('Error importing pairs: ' + error.message);
            }
        }

        // In the assessment details section
        function displayAssessmentDetails(assessment) {
            document.getElementById('assessmentDescription').textContent = assessment.description || 'No description provided';
            document.getElementById('assessmentCriteria').textContent = assessment.criteria || 'No grading criteria provided';
            document.getElementById('assessmentDueDate').textContent = assessment.dueDate ? new Date(assessment.dueDate).toLocaleString() : 'No due date set';
        }

        // Handle type change to show appropriate form
        function handleTypeChange() {
            const type = document.getElementById('type').value;
            const subtypeContainer = document.getElementById('subtypeContainer');
            const subtypeSelect = document.getElementById('subtype');
            // Remove questionButtonsContainer logic from here
            // Clear existing options
            if (subtypeSelect) {
                subtypeSelect.innerHTML = '<option value="">Select Subtype</option>';
            }
            // Show/hide subtype container based on type
            if (subtypeContainer) {
                subtypeContainer.style.display = ['drag-and-drop'].includes(type) ? 'block' : 'none';
            }
            // Update subtype options based on type
            if (type === 'drag-and-drop' && subtypeSelect) {
                subtypeSelect.innerHTML = `
                    <option value="">Select Subtype</option>
                    <option value="fill-in-blank">Fill-in-the-blank</option>
                    <option value="image-fill-blank">Image Fill-in-the-blank</option>
                    <option value="long-paragraph-fill-in-blank">Long Paragraph Fill-in-the-blank</option>
                    <option value="matching">Matching</option>
                `;
            }
            // Always call updateQuestionOptions at the end
            updateQuestionOptions();
        }

        // Function to preview audio after selection
        function previewAudio(input) {
            const audioPreview = document.getElementById('audioPreview');
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const audioUrl = URL.createObjectURL(file);
                audioPreview.src = audioUrl;
                audioPreview.style.display = 'block';
                
                // Upload the audio file when selected
                uploadAudioFile(file);
            } else {
                audioPreview.style.display = 'none';
                audioPreview.src = '';
            }
            document.getElementById('removeAudioBtn').style.display = 'inline-block';
        }
        
        // Function to upload audio file
        async function uploadAudioFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/assessments/upload-audio', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Failed to upload audio');
                }
                
                const result = await response.json();
                
                // Store the file path for form submission
                document.getElementById('audioUrl').value = result.filePath;
                
                // Show success feedback
                const audioContainer = document.getElementById('audioUploadContainer');
                // Remove any previous feedback
                const oldFeedback = audioContainer.querySelector('.upload-feedback');
                if (oldFeedback) oldFeedback.remove();
                
                // Add new feedback
                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = 'alert alert-success mt-2 upload-feedback';
                feedbackDiv.innerHTML = `<strong>Success!</strong> Audio file "${file.name}" uploaded successfully.`;
                audioContainer.querySelector('.card-body').appendChild(feedbackDiv);
            } catch (error) {
                console.error('Error uploading audio:', error);
                alert('Failed to upload audio file: ' + error.message);
            }
        }

        // Call handleTypeChange on page load to set initial state
        document.addEventListener('DOMContentLoaded', handleTypeChange);
        
        // Preview uploaded audio file
        function previewAudio(input) {
            const audioPreview = document.getElementById('audioPreview');
            const file = input.files[0];
            
            if (file) {
                const audioUrl = URL.createObjectURL(file);
                audioPreview.src = audioUrl;
                audioPreview.style.display = 'block';
                
                // Also upload the file immediately to get a server URL
                uploadAudioFile(file);
            } else {
                audioPreview.src = '';
                audioPreview.style.display = 'none';
            }
        }
        
        // Upload audio file to server
        async function uploadAudioFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/assessments/upload-audio', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('audioUrl').value = data.filePath;
                    console.log('Audio uploaded successfully:', data.filePath);
                } else {
                    alert('Failed to upload audio file');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to upload audio file');
            }
        }
        
        // Modified version of addAssessment - adding audio handling
        async function addAssessment(e) {
            e.preventDefault();
            
            // Get form values
            const sectionId = document.getElementById('sectionSelect').value;
            const title = document.getElementById('title').value;
            const description = document.getElementById('description').value;
            const type = document.getElementById('type').value;
            const category = document.getElementById('assessmentCategory').value;
            const dueDate = document.getElementById('dueDate').value;
            const maxAttempts = document.getElementById('maxAttempts').value;
            const criteria = document.getElementById('criteria').value;
            
            // Get subtype if applicable
            let subtype = '';
            if (type === 'drag-and-drop') {
                subtype = document.getElementById('subtype').value;
            }
            
            // Get audio file URL if uploaded
            const audioUrl = document.getElementById('audioUrl').value;
            
            // Validate required fields
            if (!sectionId || !title) {
                alert('Please fill in all required fields');
                return;
            }
            
            // Get all questions from questionsList
            let questions = [];
            
            try {
                // Get questions based on type
                if (type === 'multiple-choice') {
                    questions = getMultipleChoiceQuestions();
                } else if (type === 'true-false') {
                    questions = getTrueFalseQuestions();
                } else if (type === 'drag-and-drop') {
                    questions = getDragAndDropQuestions(subtype);
                } else if (type === 'matching') {
                    questions = getMatchingQuestions();
                } else if (type === 'change-sequence') {
                    // Gather all change-sequence question cards
                    const questionCards = document.querySelectorAll('.question-card[data-type="change-sequence"]');
                    questions = Array.from(questionCards).map(card => getQuestionData(card));
                }
                
                // Build form data
                const formData = new FormData();
                formData.append('title', title);
                formData.append('description', description);
                formData.append('type', type);
                formData.set('category', category);
                
                // Add subtype for drag-and-drop
                if (type === 'drag-and-drop' && subtype) {
                    formData.append('subtype', subtype);
                }
                
                // Add questions as JSON string
                formData.set('questions', JSON.stringify(questions));
                
                // Add criteria if provided
                if (criteria) {
                    formData.append('criteria', criteria);
                }
                
                // Add due date if provided
                if (dueDate) {
                    formData.append('dueDate', dueDate);
                }
                
                // Add max attempts if provided
                if (maxAttempts) {
                    formData.append('maxAttempts', maxAttempts);
                }
                
                // If audio URL exists, create a media file record
                if (audioUrl) {
                    // Add the audio URL as a media file
                    // Either append directly as a file or use the URL
                    formData.append('audioFile', audioUrl);
                }
                
                // Show loading state
                const submitBtn = document.querySelector('#assessmentForm button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Creating...';
                
                // Send request to create assessment
                const response = await fetch(`/api/sections/${sectionId}/assessments`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                
                // Reset button
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
                
                if (response.ok) {
                    const result = await response.json();
                    alert('Assessment created successfully!');
                    
                    // Reset form and reload assessments
                    document.getElementById('assessmentForm').reset();
                    clearQuestionsUi();
                    loadExistingAssessments();
                } else {
                    const error = await response.json();
                    alert(`Failed to create assessment: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error creating assessment:', error);
                alert(`Error creating assessment: ${error.message}`);
            }
        }
        
        // Update the event listener for form submission
        document.addEventListener('DOMContentLoaded', () => {
            // Also initialize the type change handler
            handleTypeChange();
        });

        function getQuestionData(card) {
            const type = card.getAttribute('data-type');
            const cardBody = card.querySelector('.card-body');
            if (!cardBody) return {};
            const question = { type };
            // Handle different question types
            switch(type) {
                case 'assignment':
                    const textWithBlanks = cardBody.querySelector('.text-with-blanks').value;
                    const instructions = cardBody.querySelector('.assignment-instructions').value;
                    const caseSensitive = cardBody.querySelector('.case-sensitive').checked;
                    
                    // Extract the blanks and answers from the format [BLANK:answer]
                    const blanksRegex = /\[BLANK:(.*?)\]/g;
                    const matches = [...textWithBlanks.matchAll(blanksRegex)];
                    
                    const answers = matches.map(match => match[1]);
                    
                    // Replace [BLANK:answer] with [BLANK] for display
                    const displayText = textWithBlanks.replace(blanksRegex, '[BLANK]');
                    
                    question.text = displayText;
                    question.rawText = textWithBlanks; // Store the original text with answers
                    question.instructions = instructions;
                    question.caseSensitive = caseSensitive;
                    
                    // Handle audio file if present
                    const audioFilePathInput = cardBody.querySelector('.audio-file-path');
                    if (audioFilePathInput && audioFilePathInput.value) {
                        question.audioPath = audioFilePathInput.value;
                    }
                    break;
                case 'change-sequence':
                    // Read items from textarea (one per line)
                    const itemsElem = cardBody.querySelector('.sequence-items');
                    const correctElem = cardBody.querySelector('.sequence-correct');
                    const itemsRaw = itemsElem?.value || '';
                    const items = itemsRaw.split(/\r?\n/).map(item => item.trim()).filter(Boolean);
                    const correctRaw = correctElem?.value || '';
                    const correctSequence = correctRaw.split(',').map(item => item.trim()).filter(Boolean);
                    question.instructions = cardBody.querySelector('.sequence-instructions')?.value || '';
                    question.items = items;
                    question.correctSequence = correctSequence;
                    question.audioDisplayName = cardBody.querySelector('.sequence-audio-display-name')?.value || '';
                    const audioPathInput = cardBody.querySelector('.audio-file-path');
                    if (audioPathInput && audioPathInput.value) {
                        question.audioPath = audioPathInput.value;
                    }
                    break;
                case 'drag-and-drop':
                    let subtype = 'sequence';
                    const subtypeSelect = cardBody.querySelector('.dragdrop-subtype-select');
                    if (subtypeSelect) {
                        subtype = subtypeSelect.value;
                    }
                    question.subtype = subtype;
                    
                    if (subtype === 'sequence') {
                        // Handle sequence
                        const audioInput = cardBody.querySelector('.sequence-audio');
                        const itemsInput = cardBody.querySelector('.sequence-items');
                        const correctInput = cardBody.querySelector('.sequence-correct');
                        const extraInput = cardBody.querySelector('.sequence-extra');
                        const audioDisplayName = cardBody.querySelector('.sequence-audio-display-name');
                        
                        question.items = itemsInput.value.split(',').map(item => item.trim()).filter(Boolean);
                        question.correctSequence = correctInput.value.split(',').map(item => item.trim()).filter(Boolean);
                        question.extra = extraInput.value.split(',').map(item => item.trim()).filter(Boolean);
                        question.audioDisplayName = audioDisplayName ? audioDisplayName.value : '';
                        // Audiofile handled separately during form submission
                    }
                    else if (subtype === 'long-paragraph-fill-in-blank') {
                        // Remove required attribute from inputs to prevent form submission issues
                        const inputs = cardBody.querySelectorAll('.dragdrop-long-paragraph-fields input');
                        inputs.forEach(input => {
                            input.removeAttribute('required');
                        });
                        const textarea = cardBody.querySelector('.long-paragraph-text');
                        if (textarea) textarea.removeAttribute('required');
                        
                        // Get the paragraph text with [BLANK] placeholders
                        const paragraphText = cardBody.querySelector('.long-paragraph-text').value;
                        question.text = paragraphText;
                        
                        // Get word bank items
                        const wordBank = cardBody.querySelector('.long-paragraph-wordbank').value
                            .split(',').map(item => item.trim()).filter(Boolean);
                        question.wordBank = wordBank;
                        
                        // Get correct answers in order
                        const correctAnswers = cardBody.querySelector('.long-paragraph-answers').value
                            .split(',').map(item => item.trim()).filter(Boolean);
                        question.answers = correctAnswers;
                        
                        // Get extra word bank items
                        const extraWords = cardBody.querySelector('.long-paragraph-extra').value
                            .split(',').map(item => item.trim()).filter(Boolean);
                        question.extraWords = extraWords;
                    }
                    // Other subtypes handled similarly
                    break;
                // Other question types handled here
            }
            
            return question;
        }
        
        // Validate drag-and-drop fields before form submission
        function validateDragAndDropFields() {
            const type = document.getElementById('type').value;
            const subtype = document.getElementById('subtype').value;
            
            // Only validate if it's a drag-and-drop with long paragraph subtype
            if (type === 'drag-and-drop' && subtype === 'long-paragraph-fill-in-blank') {
                const questionsList = document.getElementById('questionsList');
                const cards = questionsList.querySelectorAll('.question-card[data-type="drag-and-drop"]');
                
                // Validate each card
                for (const card of cards) {
                    const longParagraphFields = card.querySelector('.dragdrop-long-paragraph-fields');
                    if (!longParagraphFields || longParagraphFields.style.display === 'none') continue;
                    
                    // Get the field values
                    const paragraphText = longParagraphFields.querySelector('.long-paragraph-text').value;
                    const wordBank = longParagraphFields.querySelector('.long-paragraph-wordbank').value;
                    const answers = longParagraphFields.querySelector('.long-paragraph-answers').value;
                    
                    // Check if required fields are filled
                    if (!paragraphText.trim()) {
                        alert('Please enter the paragraph text for the long paragraph drag and drop question.');
                        longParagraphFields.querySelector('.long-paragraph-text').focus();
                        return false;
                    }
                    
                    if (!wordBank.trim()) {
                        alert('Please enter the word bank items for the long paragraph drag and drop question.');
                        longParagraphFields.querySelector('.long-paragraph-wordbank').focus();
                        return false;
                    }
                    
                    if (!answers.trim()) {
                        alert('Please enter the correct answers for the long paragraph drag and drop question.');
                        longParagraphFields.querySelector('.long-paragraph-answers').focus();
                        return false;
                    }
                    
                    // Count [BLANK] occurrences
                    const blankCount = (paragraphText.match(/\[BLANK\]/g) || []).length;
                    const answerCount = answers.split(',').filter(item => item.trim()).length;
                    
                    // Check if blank count matches answer count
                    if (blankCount !== answerCount) {
                        alert(`The number of [BLANK] placeholders (${blankCount}) doesn't match the number of answers (${answerCount}). Please ensure they match.`);
                        return false;
                    }
                    
                    // Pre-fill any hidden form fields that might have the required attribute
                    // This will prevent the "invalid form control not focusable" error
                    const questionId = card.id;
                    const answerArray = answers.split(',').map(item => item.trim());
                    
                    answerArray.forEach((answer, i) => {
                        // Try to find and populate any hidden fields that might exist
                        const expressionField = document.querySelector(`input[name="expression_question_${questionId}_${i}"]`);
                        const meaningField = document.querySelector(`input[name="meaning_question_${questionId}_${i}"]`);
                        
                        if (expressionField) expressionField.value = answer;
                        if (meaningField) meaningField.value = answer;
                    });
                }
            }
            
            return true;
        }

        function addMatchingPair(questionId) {
            const pairsContainer = document.querySelector(`#${questionId} .matching-pairs`);
            const pairCount = pairsContainer.querySelectorAll('.matching-pair').length;
            
            const pairHtml = `
                <div class="matching-pair">
                    <div class="row mb-2">
                        <div class="col-md-5">
                            <input type="text" class="form-control" name="expression_${questionId}_${pairCount}" placeholder="Enter expression">
                        </div>
                        <div class="col-md-5">
                            <input type="text" class="form-control" name="meaning_${questionId}_${pairCount}" placeholder="Enter meaning">
                        </div>
                        <div class="col-md-2">
                            <button type="button" class="btn btn-outline-danger" onclick="removeMatchingPair(this)">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>`;
            
            pairsContainer.insertAdjacentHTML('beforeend', pairHtml);
        }

        function addDragDropPair(questionId) {
            const pairsContainer = document.querySelector(`#${questionId} .dragdrop-pairs`);
            const pairCount = pairsContainer.querySelectorAll('.dragdrop-pair').length;
            
            const pairHtml = `
                <div class="dragdrop-pair">
                    <div class="row mb-2">
                        <div class="col-md-5">
                            <input type="text" class="form-control" name="expression_${questionId}_${pairCount}" placeholder="Enter expression">
                        </div>
                        <div class="col-md-5">
                            <input type="text" class="form-control" name="meaning_${questionId}_${pairCount}" placeholder="Enter meaning">
                        </div>
                        <div class="col-md-2">
                            <button type="button" class="btn btn-outline-danger" onclick="removeDragDropPair(this)">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>`;
            
            pairsContainer.insertAdjacentHTML('beforeend', pairHtml);
        }

        // Add the missing deleteAssessment function
        async function deleteAssessment(assessmentId) {
            // Confirm before deleting
            if (!confirm('Are you sure you want to delete this assessment? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/assessments/${assessmentId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    alert('Assessment deleted successfully');
                    // Reload the assessments list to reflect the deletion
                    await loadExistingAssessments();
                } else {
                    const error = await response.json();
                    alert('Error deleting assessment: ' + (error.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error deleting assessment:', error);
                alert('Failed to delete assessment. Please try again.');
            }
        }

        // Function to get multiple choice questions from the UI
        function getMultipleChoiceQuestions() {
            const questions = [];
            const questionCards = document.querySelectorAll('.question-card[data-type="multiple-choice"]');
            
            questionCards.forEach(card => {
                const questionText = card.querySelector('textarea').value.trim();
                const optionInputs = card.querySelectorAll('.input-group input[type="text"]');
                const radioInputs = card.querySelectorAll('.input-group input[type="radio"]');
                
                // Get options
                const options = Array.from(optionInputs).map(input => input.value.trim());
                
                // Find which option is selected as correct
                let correctOption = -1;
                radioInputs.forEach((radio, index) => {
                    if (radio.checked) {
                        correctOption = index;
                    }
                });
                
                // Create question object
                const question = {
                    type: 'multiple-choice',
                    text: questionText,
                    options: options,
                    correctOption: correctOption
                };
                
                questions.push(question);
            });
            
            return questions;
        }
        
        // Function to get true/false questions from the UI
        function getTrueFalseQuestions() {
            const questions = [];
            const questionCards = document.querySelectorAll('.question-card[data-type="true-false"]');
            questionCards.forEach(card => {
                const sentenceRows = card.querySelectorAll('.tf-sentence-row');
                const sentences = [];
                sentenceRows.forEach(row => {
                    const sentenceText = row.querySelector('input[type="text"]').value.trim();
                    const tfButton = row.querySelector('.tf-toggle');
                    let isTrue = null;
                    if (tfButton.dataset.state === 'T') isTrue = true;
                    else if (tfButton.dataset.state === 'F') isTrue = false;
                    sentences.push({
                        text: sentenceText,
                        isTrue: isTrue
                    });
                });
                // Only add if at least one sentence
                if (sentences.length > 0) {
                    questions.push({
                        type: 'true-false',
                        sentences: sentences
                    });
                }
            });
            return questions;
        }
        
        // Function to get drag-and-drop questions from the UI
        function getDragAndDropQuestions(subtype) {
            const questions = [];
            const questionCards = document.querySelectorAll('.question-card[data-type="drag-and-drop"]');
            
            questionCards.forEach(card => {
                const cardBody = card.querySelector('.card-body');
                if (!cardBody) return;
                
                // Create base question object
                const question = {
                    type: 'drag-and-drop',
                    subtype: subtype || 'sequence'
                };
                
                if (subtype === 'long-paragraph-fill-in-blank') {
                    // Get the paragraph text with [BLANK] placeholders
                    const paragraphText = cardBody.querySelector('.long-paragraph-text')?.value || '';
                    question.text = paragraphText;
                    
                    // Get word bank items
                    const wordBank = (cardBody.querySelector('.long-paragraph-wordbank')?.value || '')
                        .split(',').map(item => item.trim()).filter(Boolean);
                    question.wordBank = wordBank;
                    
                    // Get correct answers in order
                    const correctAnswers = (cardBody.querySelector('.long-paragraph-answers')?.value || '')
                        .split(',').map(item => item.trim()).filter(Boolean);
                    question.answers = correctAnswers;
                    
                    // Get extra word bank items
                    const extraWords = (cardBody.querySelector('.long-paragraph-extra')?.value || '')
                        .split(',').map(item => item.trim()).filter(Boolean);
                    question.extraWords = extraWords;
                    
                    // Check for audio information
                    const audioDisplayName = cardBody.querySelector('.long-paragraph-audio-display-name')?.value;
                    if (audioDisplayName) {
                        question.audioDisplayName = audioDisplayName;
                    }
                    
                    // Store the audio path if it exists
                    const audioPath = cardBody.querySelector('.audio-file-path')?.value;
                    if (audioPath) {
                        question.audioPath = audioPath;
                    }
                } else if (subtype === 'sequence') {
                    // Handle sequence subtype
                    const items = (cardBody.querySelector('.sequence-items')?.value || '')
                        .split(',').map(item => item.trim()).filter(Boolean);
                    question.items = items;
                    
                    const correctSequence = (cardBody.querySelector('.sequence-correct')?.value || '')
                        .split(',').map(item => item.trim()).filter(Boolean);
                    question.correctSequence = correctSequence;
                    
                    const extraItems = (cardBody.querySelector('.sequence-extra')?.value || '')
                        .split(',').map(item => item.trim()).filter(Boolean);
                    question.extraItems = extraItems;
                    
                    // Store audio display name if present
                    const audioDisplayName = cardBody.querySelector('.sequence-audio-display-name')?.value;
                    if (audioDisplayName) {
                        question.audioDisplayName = audioDisplayName;
                    }
                } 
                    else if (subtype === 'fill-in-blank') {
        // Collect sentences and answers
        const sentences = [];
        const sentenceRows = cardBody.querySelectorAll('.fillblank-sentences-list .fillblank-sentence-row');
        sentenceRows.forEach(row => {
            const sentenceInput = row.querySelector('input[type="text"]:nth-child(1)');
            const answersInput = row.querySelector('input[type="text"]:nth-child(2)');
            if (sentenceInput && answersInput) {
                const text = sentenceInput.value.trim();
                const answers = answersInput.value.split(',').map(a => a.trim()).filter(Boolean);
                if (text && answers.length > 0) {
                    sentences.push({ text, answers });
                }
            }
        });
        // Collect extra word bank words
        const extraInput = cardBody.querySelector('.fillblank-extra');
        const extraWords = extraInput ? extraInput.value.split(',').map(a => a.trim()).filter(Boolean) : [];
        question.sentences = sentences;
        question.extraWords = extraWords;
    }
                
                else if (subtype === 'image-fill-blank') {
                    // Collect image-sentence pairs
                    const pairs = [];
                    let allAnswers = [];
                    const pairRows = cardBody.querySelectorAll('.image-fillblank-pairs-list .card');
                    pairRows.forEach(row => {
                        let image = '';
                        const serverPathInput = row.querySelector('input.image-server-path');
                        const fileInput = row.querySelector('input[type="file"].image-input');
                        const textInput = row.querySelector('input[type="text"].image-input');
                        if (serverPathInput && serverPathInput.value) {
                            image = serverPathInput.value;
                        } else if (fileInput && fileInput.files && fileInput.files[0]) {
                            // fallback, should not be used if upload worked
                            image = '/uploads/resources/' + fileInput.files[0].name;
                        } else if (textInput && textInput.value) {
                            image = textInput.value.trim();
                        }
                        const text = row.querySelector('input.sentence-input')?.value.trim() || '';
                        const answer = row.querySelector('input.answer-input')?.value.trim() || '';
                        if (image && text && answer) {
                            pairs.push({ image, text, answers: [answer] });
                            allAnswers.push(answer); // collect for word bank
                        }
                    });
                    // Collect extra word bank words
                    const extraInput = cardBody.querySelector('.imagefillblank-extra');
                    const extraWords = extraInput ? extraInput.value.split(',').map(a => a.trim()).filter(Boolean) : [];
                    question.sentences = pairs;
                    question.extraWords = extraWords;
                    // Build the word bank: all correct answers (with duplicates) + extra words
                    question.words = allAnswers.concat(extraWords);
                }
                
                questions.push(question);
            });
            
            return questions;
        }
        
        // Function to get matching questions from the UI
        function getMatchingQuestions() {
            const questions = [];
            const questionCards = document.querySelectorAll('.question-card[data-type="matching"]');
            
            questionCards.forEach(card => {
                // Get all matching pairs
                const pairRows = card.querySelectorAll('.matching-pair');
                const expressions = [];
                const meanings = [];
                const pairs = [];
                
                pairRows.forEach(row => {
                    const expressionInput = row.querySelector('input[placeholder="Enter expression"]');
                    const meaningInput = row.querySelector('input[placeholder="Enter meaning"]');
                    
                    if (expressionInput && meaningInput) {
                        const expression = expressionInput.value.trim();
                        const meaning = meaningInput.value.trim();
                        
                        if (expression && meaning) {
                            expressions.push(expression);
                            meanings.push(meaning);
                            pairs.push({
                                expression: expression,
                                meaning: meaning
                            });
                        }
                    }
                });
                
                // Create question object with both formats for compatibility
                const question = {
                    type: 'matching',
                    expressions: expressions,
                    meanings: meanings,
                    pairs: pairs
                };
                
                questions.push(question);
            });
            
            return questions;
        }

        // Function to clear all questions from the UI
        function clearQuestionsUi() {
            const questionsList = document.getElementById('questionsList');
            if (questionsList) {
                // Remove all question cards
                const questionCards = questionsList.querySelectorAll('.question-card');
                questionCards.forEach(card => card.remove());
                
                // Reset any other UI elements related to questions if needed
                const noQuestionsMsg = document.getElementById('noQuestionsMsg');
                if (noQuestionsMsg) {
                    noQuestionsMsg.style.display = 'block';
                }
            }
        }

        // Upload audio file specifically for assignment questions
        async function uploadAssignmentAudio(file, audioFilePathInput) {
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/assessments/upload-audio', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('Failed to upload audio');
                }
                
                const result = await response.json();
                
                // Store the file path in the hidden input
                if (audioFilePathInput) {
                    audioFilePathInput.value = result.filePath;
                    console.log('Audio file path saved:', result.filePath);
                }
            } catch (error) {
                console.error('Error uploading assignment audio:', error);
                alert('Failed to upload audio file: ' + error.message);
            }
        }

        // Show/hide buttons based on mode
        function showEditMode() {
            document.getElementById('createAssessmentBtn').style.display = 'none';
            document.getElementById('saveAssessmentBtn').style.display = 'inline-block';
        }
        function showCreateMode() {
            document.getElementById('createAssessmentBtn').style.display = 'inline-block';
            document.getElementById('saveAssessmentBtn').style.display = 'none';
        }
        // Example usage: call showEditMode() when editing, showCreateMode() when resetting form
        // You should call showEditMode() inside your editAssessment(assessmentId) function after loading data
        // And call showCreateMode() after saving or when resetting the form

        document.getElementById('removeAudioBtn').addEventListener('click', function() {
            const audioInput = document.getElementById('assessmentAudio');
            const audioPreview = document.getElementById('audioPreview');
            const audioUrl = document.getElementById('audioUrl');
            if (audioInput) audioInput.value = '';
            if (audioPreview) {
                audioPreview.src = '';
                audioPreview.style.display = 'none';
            }
            if (audioUrl) audioUrl.value = '';
            this.style.display = 'none';
            const audioContainer = document.getElementById('audioUploadContainer');
            if (audioContainer) {
                const oldFeedback = audioContainer.querySelector('.upload-feedback');
                if (oldFeedback) oldFeedback.remove();
            }
        });

        // Add this function after the existing functions
        async function handleSequenceAudioUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const preview = input.parentElement.querySelector('.audio-preview');
            const audioFilePathInput = input.parentElement.querySelector('.audio-file-path');
            
            if (preview && file) {
                // Create audio element
                preview.style.display = 'block';
                preview.innerHTML = `
                    <audio controls class="w-100">
                        <source src="${URL.createObjectURL(file)}" type="${file.type}">
                        Your browser does not support the audio element.
                    </audio>
                    <p class="text-muted small mt-1">${file.name}</p>
                `;
                
                // Upload the audio file to server and store path
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    const response = await fetch('/api/assessments/upload-audio', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        },
                        body: formData
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (audioFilePathInput) {
                            audioFilePathInput.value = data.filePath;
                            console.log('Audio file path saved:', data.filePath);
                        }
                    } else {
                        throw new Error('Failed to upload audio');
                    }
                } catch (error) {
                    console.error('Error uploading audio:', error);
                    alert('Failed to upload audio file: ' + error.message);
                }
            }
        }

        // After rendering the drag-and-drop question card, add preview/upload logic for the optional image:
        document.querySelectorAll('.optional-image-input').forEach(input => {
            const previewDiv = input.parentElement.querySelector('.optional-image-preview');
            const serverPathInput = input.parentElement.querySelector('.optional-image-server-path');
            input.addEventListener('change', async function() {
                if (this.files && this.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        previewDiv.innerHTML = `<img src="${e.target.result}" class="img-fluid">`;
                    };
                    reader.readAsDataURL(this.files[0]);
                    // Upload image to server
                    const formData = new FormData();
                    formData.append('file', this.files[0]);
                    try {
                        const response = await fetch('/api/assessments/upload-audio', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${localStorage.getItem('token')}`
                            },
                            body: formData
                        });
                        if (response.ok) {
                            const data = await response.json();
                            serverPathInput.value = data.filePath;
                        } else {
                            alert('Failed to upload image.');
                        }
                    } catch (error) {
                        alert('Error uploading image: ' + error.message);
                    }
                }
            });
        });
        // In getDragAndDropQuestions, save the optional image path:
        // ... existing code ...
        if (subtype === 'sequence' || subtype === 'fill-in-blank' || subtype === 'image-fill-blank' || subtype === 'long-paragraph-fill-in-blank' || subtype === 'matching') {
            const optionalImagePath = cardBody.querySelector('.optional-image-server-path')?.value;
            if (optionalImagePath) {
                question.optionalImage = optionalImagePath;
            }
        }
        // ... existing code ...

        async function viewAssessment(assessmentId) {
            try {
                const response = await fetch(`/api/assessments/${assessmentId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to fetch assessment');
                const assessment = await response.json();
                let html = `<h5>${assessment.title}</h5>`;
                html += `<p><strong>Description:</strong> ${assessment.description || ''}</p>`;
                html += `<p><strong>Type:</strong> ${assessment.type}</p>`;
                html += `<p><strong>Category:</strong> ${assessment.category || 'N/A'}</p>`;
                html += `<p><strong>Section:</strong> ${assessment.section.part.unit.subject.name} > ${assessment.section.part.unit.name} > ${assessment.section.part.name} > ${assessment.section.name}</p>`;
                html += `<hr><h6>Questions:</h6>`;
                if (Array.isArray(assessment.questions) && assessment.questions.length > 0) {
                    assessment.questions.forEach((q, i) => {
                        html += `<div class='mb-2'><strong>Q${i+1}:</strong> `;
                        if (q.type === 'true-false' && Array.isArray(q.sentences)) {
                            q.sentences.forEach((s, idx) => {
                                html += `<div>${s.text} <span class='badge bg-${s.isTrue ? 'success' : 'danger'} ms-2'>${s.isTrue ? 'True' : 'False'}</span></div>`;
                            });
                        } else if (q.type === 'multiple-choice' && q.text && Array.isArray(q.choices)) {
                            html += `<div>${q.text}</div><ul>`;
                            q.choices.forEach((choice, idx) => {
                                html += `<li${choice.isCorrect ? ' style=\'font-weight:bold;color:green;\'' : ''}>${String.fromCharCode(65+idx)}. ${choice.text}${choice.isCorrect ? ' (Correct)' : ''}</li>`;
                            });
                            html += `</ul>`;
                        } else {
                            html += `<pre>${JSON.stringify(q, null, 2)}</pre>`;
                        }
                        html += `</div>`;
                    });
                } else {
                    html += '<div>No questions found.</div>';
                }
                document.getElementById('viewAssessmentModalBody').innerHTML = html;
                const modal = new bootstrap.Modal(document.getElementById('viewAssessmentModal'));
                modal.show();
            } catch (error) {
                alert('Failed to load assessment for viewing: ' + error.message);
            }
        }

        // In the JS section, add this function:
        function openAssessmentView(assessmentId) {
            const windowWidth = 900;
            const windowHeight = 700;
            const left = window.screen.width - windowWidth;
            const top = 0;
            window.open(
                `/teacher/assessment-view.html?assessmentId=${assessmentId}`,
                '_blank',
                `width=${windowWidth},height=${windowHeight},left=${left},top=${top},scrollbars=yes,resizable=yes`
            );
        }

        // Add filter logic for quarter and published
        function getAssessmentFilters() {
            const quarter = document.getElementById('quarterFilter').value;
            const published = document.getElementById('publishedFilter').value;
            return { quarter, published };
        }
        async function fetchAssessmentsWithFilters() {
            const { quarter, published } = getAssessmentFilters();
            let url = '/api/teacher/assessments?';
            if (quarter) url += `quarter=${encodeURIComponent(quarter)}&`;
            if (published) url += `published=${encodeURIComponent(published)}&`;
            // Remove trailing & or ?
            url = url.replace(/[&?]$/, '');
            // ...existing fetch logic, replace the fetch URL with 'url'...
            // Example:
            // const res = await fetch(url, { headers: { 'Authorization': `Bearer ${token}` } });
            // ...rest of your fetch logic...
        }
        document.getElementById('quarterFilter').addEventListener('change', fetchAssessmentsWithFilters);
        document.getElementById('publishedFilter').addEventListener('change', fetchAssessmentsWithFilters);
        // ...existing code to call fetchAssessmentsWithFilters() on page load...
        // ... existing code ...
    </script>
    <!-- Modal for viewing assessment as teacher -->
    <div class="modal fade" id="viewAssessmentModal" tabindex="-1" aria-labelledby="viewAssessmentModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="viewAssessmentModalLabel">Assessment Details</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body" id="viewAssessmentModalBody">
            <!-- Content will be injected by JS -->
          </div>
        </div>
      </div>
    </div>
</body>
</html>